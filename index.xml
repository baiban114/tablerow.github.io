<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>彦祖，你又来了</title>
    <link>http://tablerows.gitee.io/tablerow.github.io/</link>
    <description>Recent content on 彦祖，你又来了</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 09 Apr 2022 18:53:28 +0800</lastBuildDate>
    
        <atom:link href="http://tablerows.gitee.io/tablerow.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>网络寻址</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/</link>
        <pubDate>Sat, 09 Apr 2022 18:53:28 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/ -&lt;h1 id=&#34;套接字&#34;&gt;套接字&lt;/h1&gt;
&lt;h1 id=&#34;url&#34;&gt;URL&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img.php.cn/upload/article/000/000/024/5c09e320694b4361.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;URL（统一资源定位符）是Internet上资源的地址，可以定义为引用地址的字符串，用于指示资源的位置以及用于访问它的协议。&lt;/p&gt;
&lt;p&gt;URL是在网络上定位资源的最普遍使用的方式，它提供了一种通过描述其网络位置或主要访问机制来检索物理位置的表示的方法。&lt;/p&gt;
&lt;p&gt;URL中描述了协议，该URL用于检索资源和资源名称。如果资源是Web类型资源，则URL在开头包含http / https。同样，如果资源是文件，则以ftp开头，如果资源是电子邮件地址，则以mailto开头。&lt;/p&gt;
&lt;p&gt;URL包含以下信息：&lt;/p&gt;
&lt;p&gt;1、用于访问资源的协议&lt;/p&gt;
&lt;p&gt;2、服务器的位置（无论是通过IP地址还是域名）&lt;/p&gt;
&lt;p&gt;3、服务器上的端口号（可选）&lt;/p&gt;
&lt;p&gt;4、资源在服务器目录结构中的位置&lt;/p&gt;
&lt;p&gt;5、片段标识符（可选）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 端口是只在http默认80还是？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：https://blog.csdn.net/qq_44915801&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL中有些字符不能出现，有些是有其他含义，比如&#39;+&#39;。想要再url中使用这些符号，可以使用他们的编码，比如数据库连接的url中设置时区的”GMT+8“可以写作”GMT%2B8“&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;uri&#34;&gt;URI&lt;/h1&gt;
&lt;p&gt;URI（统一资源标识符）是标识逻辑或物理资源的字符序列，与URL类似，也是一串字符。通过使用位置，名称或两者来标识Internet上的资源；它允许统一识别资源。&lt;/p&gt;
&lt;p&gt;有两种类型的URI，统一资源标识符（URL）和统一资源名称（URN）。&lt;/p&gt;
&lt;p&gt;任何URI的通用形式都是：&lt;/p&gt;
&lt;p&gt;scheme：[// [user：password @] host [：port]] [/] path [？查询] [#片段]&lt;/p&gt;
&lt;p&gt;Scheme（方案）：该方案列出了具体语法和URI的任何相关协议。方案不区分大小写，后跟冒号。理想情况下，URI方案应该在互联网号码分配机构（IANA）注册，但也可以使用非注册方案。&lt;/p&gt;
&lt;p&gt;权限组件：权限组件由多个部分组成：可选的身份验证部分，主机（由注册名称或IP地址组成） , 以及可选的端口号。身份验证部分包含用户名和密码，用冒号分隔，后跟at（@）符号。在@之后是主机名，然后是冒号，然后是一个端口号。请务必注意，IPv4地址必须采用点十进制表示法，并且IPv6地址必须括在括号中。&lt;/p&gt;
&lt;p&gt;查询（可选）：查询包含一串非分层数据。虽然语法没有明确定义，但通常是由分隔符分隔的属性值对序列，例如＆符号或分号。查询通过问号与前一部分分开。&lt;/p&gt;
&lt;p&gt;片段（可选）：片段包含片段标识符，该标识符为辅助资源提供方向。&lt;/p&gt;
&lt;p&gt;URL和URI之间的主要区别&lt;/p&gt;
&lt;p&gt;URL是统一资源定位器，用于标识资源；URI（统一资源标识符）提供了更简单和可扩展的标识资源的方法。URL是URI的子集&lt;/p&gt;
&lt;p&gt;1、作用的区别&lt;/p&gt;
&lt;p&gt;URL（统一资源定位符）主要用于链接网页，网页组件或网页上的程序，借助访问方法（http，ftp，mailto等协议）来检索位置资源。&lt;/p&gt;
&lt;p&gt;URI（统一资源标识符）用于定义项目的标识，此处单词标识符表示无论使用的方法是什么（URL或URN），都要将一个资源与其他资源区分开来。&lt;/p&gt;
&lt;p&gt;2、可以说URL是URI（URL是URI的子集），但URI永远不能是URL。&lt;/p&gt;
&lt;p&gt;3、协议区别&lt;/p&gt;
&lt;p&gt;URL指定要使用的协议类型，而URI不涉及协议规范。&lt;/p&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/ - </description>
        </item>
    
    
    
        <item>
        <title>设计模式</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Tue, 11 Jan 2022 21:53:15 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ -&lt;p&gt;&lt;img src=&#34;https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg&#34; alt=&#34;alt&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;设计模式的六大原则&#34;&gt;设计模式的六大原则&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1、开闭原则（Open Close Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开闭原则的意思是：&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、里氏代换原则（Liskov Substitution Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、依赖倒转原则（Dependence Inversion Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、迪米特法则，又称最少知道原则（Demeter Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、合成复用原则（Composite Reuse Principle）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。&lt;/p&gt;
&lt;h1 id=&#34;创建型模式&#34;&gt;创建型模式&lt;/h1&gt;
&lt;h2 id=&#34;工厂模式factory-pattern&#34;&gt;工厂模式（Factory Pattern）&lt;/h2&gt;
&lt;p&gt;接口Factory直接对应接口（接口指向实现类）？&lt;/p&gt;
&lt;h3 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h3&gt;
&lt;p&gt;工厂对简单工厂多一层抽象，抽象工厂再多一层&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;简单工厂（非23）&lt;/td&gt;
&lt;td&gt;具体工厂，生产产品&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;工厂&lt;/td&gt;
&lt;td&gt;工厂类有统一接口，生产一类产品（鼠标；颜色）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抽象工厂&lt;/td&gt;
&lt;td&gt;同类工厂每个厂可以生产多个产品，或一个产品可以多种品牌&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总之就是接口向上提了一层，类似多级索引或多维数组，多一层就多了一种可能（系统太复杂了加一层？）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;工厂&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;耳麦接口&lt;/td&gt;
&lt;td&gt;工厂接口内加入生产耳麦方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实现戴尔耳麦、惠普耳麦&lt;/td&gt;
&lt;td&gt;实现惠普工厂、戴尔工厂，实现生产方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;FactoryProducer不变（若加入新品牌华为就改改）&lt;/p&gt;
&lt;p&gt;这菜鸟教程不还是if else么（半恼&lt;/p&gt;
&lt;h2 id=&#34;单例模式singleton-pattern&#34;&gt;单例模式（Singleton Pattern）&lt;/h2&gt;
&lt;p&gt;**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;
&lt;p&gt;**主要解决：**一个全局使用的类频繁地创建与销毁。(创建与销毁是有成本的，创建不必要的也会浪费资源)&lt;/p&gt;
&lt;p&gt;**关键代码：**构造函数是私有的。在类内部创建一个自己的静态实例。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;没有接口，不能继承，与==单一职责原则==（？）冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化&lt;/p&gt;
&lt;h3 id=&#34;饿汉式&#34;&gt;饿汉式&lt;/h3&gt;
&lt;p&gt;==定义静态成员变量时就创建对象==&lt;/p&gt;
&lt;p&gt;**是否 Lazy 初始化：**否&lt;/p&gt;
&lt;p&gt;**是否多线程安全：**是&lt;/p&gt;
&lt;p&gt;**实现难度：**易&lt;/p&gt;
&lt;p&gt;**描述：**这种方式比较常用，但容易产生垃圾对象。
优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。
它基于 classloader 机制避免了多线程的同步问题，不过，实例在==类装载==时就实例化，虽然导致类装载的原因有很多种，这时候初始化 instance 显然没有达到 lazy loading 的效果。&lt;/p&gt;
&lt;p&gt;在getInstance()方法中不用再考虑实例是否在为空时需要创建，直接返回即可。&lt;/p&gt;
&lt;p&gt;###懒汉式&lt;/p&gt;
&lt;p&gt;等到调用getInstance()方法的时候再创建对象。&lt;/p&gt;
&lt;p&gt;由于创建对象时已进入临界区，如果不加Synchronized锁的话不能线程安全。&lt;/p&gt;
&lt;h3 id=&#34;双检锁双重校验锁dcl-double-checked-locking&#34;&gt;双检锁/双重校验锁（DCL， double-checked locking）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;why双锁模式下还有高性能？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.使用volatile修饰我们的对象引用
2.外部if判断对象是否为null，为null往下执行，不为null直接返回对象
3.使用syn同步进入代码块，使用if判断对象是否为null，为null就创建对象
4.使用volatile修饰成员变量的原因就是防止重排序的问题&amp;mdash;&amp;gt;变量还未完全初始化就被线程B返回了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Singleton&lt;/span&gt; {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton singleton;  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;Singleton&lt;/span&gt; (){}  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; Singleton &lt;span style=&#34;color:#008b45&#34;&gt;getSingleton&lt;/span&gt;() {  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (singleton == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;synchronized&lt;/span&gt; (Singleton.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;) {  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (singleton == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {  
            singleton = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Singleton();  
        }  
        }  
    }  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; singleton;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- http://tablerows.gitee.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ - </description>
        </item>
    
    
    
        <item>
        <title>应用层网络协议</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Sat, 28 Aug 2021 16:16:32 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/ -&lt;ul&gt;
&lt;li&gt;网络协议：约定的信息传输的格式，如几个字节是消息头、消息头记录什么信息之类的；&lt;/li&gt;
&lt;li&gt;c/s架构：不一定是两台计算机，而是两个应用、两个端口&lt;/li&gt;
&lt;li&gt;工具：实际使用中不用手动封装协议再发消息，而是直接使用封装的软件、库等实现功能。如SSH工具OpenSSH&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/tablerows/tianrun/raw/master/imgs/20220306212211.jpg&#34; alt=&#34;网络协议&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;命令行常用&#34;&gt;命令行常用&lt;/h1&gt;
&lt;p&gt;一些协议名和命令名一样（或相似）的协议&lt;/p&gt;
&lt;h2 id=&#34;ssh&#34;&gt;SSH&lt;/h2&gt;
&lt;p&gt;Secure Shell(SSH 安全外壳协议) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络==协议==。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全！&lt;/li&gt;
&lt;li&gt;方便！两台机器间不用输入账号密码就可验证身份！（通过保存在服务器和客户端上的密钥）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ssh可以传输文本与二进制文件；&lt;/p&gt;
&lt;p&gt;主要应用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程登录（可免密码）、github仓库操作&lt;/li&gt;
&lt;li&gt;文件传输（如hdfs）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssh的安全机制&#34;&gt;SSH的安全机制&lt;/h3&gt;
&lt;p&gt;SSH之所以能够保证安全，原因在于它采用了==非对称加密技术(RSA)==加密了所有传输的数据。&lt;/p&gt;
&lt;p&gt;传统的网络服务程序，如FTP、POP？和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到==中间人==（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。&lt;/p&gt;
&lt;p&gt;但并不是说SSH就是绝对安全的，因为它本身提供两种级别的验证方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人攻击”这种方式的攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;传统的账号密码验证？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第二种级别（基于密钥的安全验证）：你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下（该服务器上你用的账号）寻找你（客户端）的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密“质询”(challenge)并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。与第一种级别相比，第二种级别不仅加密所有传输的数据，也不需要在网络上传送口令，因此安全性更高，可以有效防止中间人攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/tablerows/tianrun/raw/master/imgs/20210831010042.png&#34; alt=&#34;ssh&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 有没有命令行传文件的例子？传id的是个专门的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常使用的软件工具为OpenSSH&lt;/p&gt;
&lt;p&gt;####基于密钥的安全验证-事前准备&lt;/p&gt;
&lt;p&gt;常用于免密登录。如果想通过输入密码的方式登录则不需要这步准备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在本机生成一对密钥（即私钥与公钥）：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh-keygen -t rsa   &lt;span style=&#34;color:#228b22&#34;&gt;#-t表示类型选项，这里采用rsa加密算法&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后根据提示一步步的按enter键即可（其中有一个提示是要求设置私钥口令passphrase，不设置则为空，这里看心情吧，如果不放心私钥的安全可以设置一下），执行结束以后会在 /home/当前用户 目录下生成一个 .ssh 文件夹,其中包含私钥文件 id_rsa 和公钥文件 id_rsa.pub。（还有known_hosts不知道有用没）
&lt;strong&gt;将公钥复制到远程主机中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用ssh-copy-id命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 ~/ .ssh/authorized_keys文件中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh-copy-id 用户名@ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样以后登录这台远程主机就不用账号密码了~&lt;/p&gt;
&lt;h4 id=&#34;服务端准备&#34;&gt;服务端准备&lt;/h4&gt;
&lt;p&gt;centos7和windows默认带有SSH工具；（OpenSSH?）可以用一下命令检查：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;rpm -qa | grep ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先确认服务器上的ssh-server是否已经启动了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ps -e | grep ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;SSH默认使用22端口，注意开放端口。&lt;/p&gt;
&lt;p&gt;每登录一台新的主机，就会将它添加到已知主机列表。&lt;/p&gt;
&lt;h4 id=&#34;远程登陆&#34;&gt;远程登陆&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ssh 用户名@ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;口令（密码）级别使用时会提示输入密码；&lt;/p&gt;
&lt;p&gt;若不填写用户名，则会默认以当前计算机登录的用户名尝试登录服务器&lt;/p&gt;
&lt;p&gt;**退出：**输入logout（linux命令？） 或者exit，或直接关闭终端/进程&lt;/p&gt;
&lt;h3 id=&#34;拓展github码云上的ssh&#34;&gt;拓展：github、码云上的SSH&lt;/h3&gt;
&lt;p&gt;可以在网页端操作，为==账户==生成SSH key公钥；除了账户SSH key外，仓库也有key，但只供拉取权限；&lt;/p&gt;
&lt;p&gt;毕竟仓库拉可以随便拉，推需要验证身份；&lt;/p&gt;
&lt;p&gt;这也是SSH相对于https的优越之处：每次fetch和push时不再需要麻烦地输入账号密码（远程登陆也不需要账号密码了）；&lt;/p&gt;
&lt;p&gt;##SSL&amp;amp;&amp;amp;TLS&lt;/p&gt;
&lt;p&gt;SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。&lt;/p&gt;
&lt;p&gt;为Netscape所研发。&lt;/p&gt;
&lt;p&gt;SSL协议位于TCP/IP协议]与各种应用层协议之间，为数据通讯提供安全支持。[SL协议可分为两层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。&lt;/li&gt;
&lt;li&gt;SSL握手协议SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;p&gt;1）认证用户和服务器，确保数据发送到正确的客户机和服务器；&lt;/p&gt;
&lt;p&gt;2）加密数据以防止数据中途被窃取；&lt;/p&gt;
&lt;p&gt;3）维护数据的完整性，确保数据在传输过程中不被改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 流程图之类的在计网书中有吗&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ftp&#34;&gt;FTP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;明文传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件传输协议（File Transfer Protocol，FTP）是用于在&lt;a href=&#34;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C&#34;&gt;网络&lt;/a&gt;上进行文件传输的一套标准协议。FTP是ARPANet（阿帕网）的标准文件传输协议。&lt;/p&gt;
&lt;p&gt;FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。&lt;/p&gt;
&lt;p&gt;FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接，一条是数据连接，用于数据传送；另一条是控制连接，用于传送控制信息（命令和响应），这种将命令和数据分开传送的思想大大提高了 FTP 的效率，而其它客户服务器应用程序一般只有一条 TCP 连接。&lt;/p&gt;
&lt;h3 id=&#34;使用-1&#34;&gt;使用&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;centos上自带的ftp工具真他娘的多啊，，反正平时用不到，现在都是用web的http传文件，，了解即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ftp-1&#34;&gt;ftp&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 怎么搞服务器？&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;ftp [-dignv][主机名称或IP地址]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d 详细显示指令执行过程，便于排错或分析程序执行的情形。&lt;/li&gt;
&lt;li&gt;-i 关闭互动模式，不询问任何问题。&lt;/li&gt;
&lt;li&gt;-g 关闭本地主机文件名称支持特殊字符的扩充特性。&lt;/li&gt;
&lt;li&gt;-n 不使用自动登陆。&lt;/li&gt;
&lt;li&gt;-v 显示指令执行过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如使用ftp命令匿名登录ftp.kernel.org服务器，该服务是Linux 内核的官方服务器，可以使用如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ftp ftp.kernel.org #发起链接请求 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;ncftp&#34;&gt;ncftp&lt;/h4&gt;
&lt;p&gt;Centos有自带的ncftp客户端软件，可用于从ftp服务器接受文件。&lt;/p&gt;
&lt;p&gt;Linux ncftp命令用于传输文件。&lt;/p&gt;
&lt;p&gt;当不指定用户名时，ncftp 命令会自动尝试使用匿名账户anonymous 去连接远程FTP 服 务器，不需要用户输入账号和密码。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ncftp [host]
ncftp [ftp://host.name/directory/]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 不指定端口？是因为固定端口吗？&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 有没有上传的方法？&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 这个似乎只能连接，不能设置为服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ncftp的命令基本上与ftp相同，例如可以使用&amp;quot;cd&amp;quot;命令切换在FTP服务器中的当前目录，使用&amp;quot;ls&amp;quot;命令列出当前目录内容，使用&amp;quot;get 文件名&amp;quot;命令下载&amp;quot;/pub&amp;quot;目录下的README文件、使用&amp;quot;quit&amp;quot;离开ncftp等&lt;/p&gt;
&lt;p&gt;与ftp不同的是，ncftp此时会提示用户是否将FTP服务器保存为书签，以便于下次登录，用户可以进行自定义书签名等操作，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;You have not saved a bookmark &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; this site.  &lt;span style=&#34;color:#228b22&#34;&gt;#离开提示信息  &lt;/span&gt;
Would you like to save a bookmark to:  
ftp://ftp.kernel.org/pub/  
Save? (yes/no) yes                            &lt;span style=&#34;color:#228b22&#34;&gt;#确认是否保存  &lt;/span&gt;
Enter a name &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; this bookmark, or hit enter &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;kernel&amp;#34;&lt;/span&gt;: kernel &lt;span style=&#34;color:#228b22&#34;&gt;#输入书签名  &lt;/span&gt;
Bookmark &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;kernel&amp;#34;&lt;/span&gt; saved. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注：在ncftp的官网有一系列Ncftp软件，覆盖服务端、上传下载等功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;tftp&#34;&gt;tftp&lt;/h4&gt;
&lt;p&gt;tftp是简单的文字模式ftp程序，它所使用的指令和FTP类似。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tftp [主机名称或IP地址]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;其他相关命令&#34;&gt;其他相关命令&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;ftpwho 				&lt;span style=&#34;color:#228b22&#34;&gt;#查询当前有哪些用户正在登录FTP服务器&lt;/span&gt;
ftpcount            &lt;span style=&#34;color:#228b22&#34;&gt;#查询当前FTP用户的人数 &lt;/span&gt;
ftpshut				&lt;span style=&#34;color:#228b22&#34;&gt;#指定时间关闭ftp服务器&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;tftp-1&#34;&gt;tftp&lt;/h2&gt;
&lt;p&gt;TFTP（Trivial File Transfer Protocol,简单&lt;a href=&#34;https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&#34;&gt;文件传输协议&lt;/a&gt;）是TCP/IP协议族中的一个用来在客户机与&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;服务器&lt;/a&gt;之间进行简单文件传输的协议，提供不复杂、开销不大的&lt;a href=&#34;https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1/5389842&#34;&gt;文件传输服务&lt;/a&gt;。&lt;a href=&#34;https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658&#34;&gt;端口号&lt;/a&gt;为69。&lt;/p&gt;
&lt;p&gt;此协议设计的时候是进行小&lt;a href=&#34;https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93&#34;&gt;文件传输&lt;/a&gt;的。因此它不具备通常的FTP的许多功能，它只能从&lt;a href=&#34;https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;文件服务器&lt;/a&gt;上获得或写入文件，不能列出目录，不进行认证，它传输8位数据。传输中有三种模式：netascii，这是8位的ASCII码形式，另一种是octet，这是8位源&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;数据类型&lt;/a&gt;；最后一种mail已经不再支持，它将返回的数据直接返回给用户而不是保存为文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tftp [主机名称或IP地址]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;连接后使用命令和ftp类似：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connect：连接到远程tftp服务器&lt;/li&gt;
&lt;li&gt;mode：文件传输模式&lt;/li&gt;
&lt;li&gt;put：上传文件&lt;/li&gt;
&lt;li&gt;get：下载文件&lt;/li&gt;
&lt;li&gt;quit：退出&lt;/li&gt;
&lt;li&gt;verbose：显示详细的处理信息&lt;/li&gt;
&lt;li&gt;trace：显示包路径&lt;/li&gt;
&lt;li&gt;status：显示当前状态信息&lt;/li&gt;
&lt;li&gt;binary：二进制传输模式&lt;/li&gt;
&lt;li&gt;ascii：ascii 传送模式&lt;/li&gt;
&lt;li&gt;rexmt：设置包传输的超时时间&lt;/li&gt;
&lt;li&gt;timeout：设置重传的超时时间&lt;/li&gt;
&lt;li&gt;help：帮助信息&lt;/li&gt;
&lt;li&gt;? ：帮助信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;telnet&#34;&gt;telnet&lt;/h2&gt;
&lt;p&gt;在命令行实现远程登录、控制。远程登录需要用户名和密码，登陆后可以远程执行命令。属于C/S模型的服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明文传输&lt;/li&gt;
&lt;li&gt;主要传输字符串（命令与输出），不适合传文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;telnet ip 端口
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可用于测试端口是否连通、占用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/Telnet%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95&#34;&gt;Telnet远程登录&lt;/a&gt;服务分为以下4个过程：&lt;/p&gt;
&lt;p&gt;1）本地与远程&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&#34;&gt;主机&lt;/a&gt;建立连接。该过程实际上是建立一个TCP连接，用户必须知道远程&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&#34;&gt;主机&lt;/a&gt;的Ip地址或&lt;a href=&#34;https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D&#34;&gt;域名&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;2）将&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E7%BB%88%E7%AB%AF&#34;&gt;本地终端&lt;/a&gt;上输入的用户名和口令及以后输入的任何命令或字符以&lt;a href=&#34;https://baike.baidu.com/item/NVT&#34;&gt;NVT&lt;/a&gt;（Net Virtual Terminal）格式传送到远程主机。该过程实际上是从&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA&#34;&gt;本地主机&lt;/a&gt;向远程主机发送一个IP数据包；&lt;/p&gt;
&lt;p&gt;3）将远程&lt;a href=&#34;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&#34;&gt;主机&lt;/a&gt;输出的&lt;a href=&#34;https://baike.baidu.com/item/NVT&#34;&gt;NVT&lt;/a&gt;格式的数据转化为本地所接受的格式送回&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E7%BB%88%E7%AB%AF&#34;&gt;本地终端&lt;/a&gt;，包括输入命令&lt;a href=&#34;https://baike.baidu.com/item/%E5%9B%9E%E6%98%BE&#34;&gt;回显&lt;/a&gt;和命令执行结果；&lt;/p&gt;
&lt;p&gt;4）最后，&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%AC%E5%9C%B0%E7%BB%88%E7%AB%AF&#34;&gt;本地终端&lt;/a&gt;对远程主机进行撤消连接。该过程是撤销一个TCP连接。&lt;/p&gt;
&lt;h3 id=&#34;适应异构-nvt&#34;&gt;适应异构-NVT&lt;/h3&gt;
&lt;p&gt;类似虚拟机的思想。太复杂就加一层！&lt;/p&gt;
&lt;p&gt;为了使多个&lt;a href=&#34;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&#34;&gt;操作系统&lt;/a&gt;间的Telnet交互操作成为可能，就必须详细了解异构计算机和操作系统。比如，一些&lt;a href=&#34;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&#34;&gt;操作系统&lt;/a&gt;需要每行文本用ASCⅡ回车控制符（CR）结束，另一些系统则需要使用换行符（LF），还有一些系统需要用两个字符的序列回车-换行（CR-LF）；再比如，大多数操作系统为用户提供了一个中断程序运行的&lt;a href=&#34;https://baike.baidu.com/item/%E5%BF%AB%E6%8D%B7%E9%94%AE&#34;&gt;快捷键&lt;/a&gt;，但这个快捷键在各个系统中有可能不同（一些系统使用CTRL+C，而另一些系统使用ESCAPE）。&lt;/p&gt;
&lt;p&gt;为了适应异构环境，Telnet协议定义了数据和命令在Internet上的传输方式，此定义被称作网络&lt;a href=&#34;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF&#34;&gt;虚拟终端&lt;/a&gt;&lt;a href=&#34;https://baike.baidu.com/item/NVT&#34;&gt;NVT&lt;/a&gt;（Net Virtual Terminal）。它的应用过程如下：　对于发送的数据：客户机&lt;a href=&#34;https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6&#34;&gt;软件&lt;/a&gt;把来自用户终端的按键和命令序列转换为NVT格式，并发送到&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;服务器&lt;/a&gt;，服务器软件将收到的数据和命令，从NVT格式转换为远地系统需要的格式；　对于返回的数据：远地服务器将数据从远地机器的格式转换为NVT格式，而本地客户机将接收到的NVT格式数据再转换为本地的格式。&lt;/p&gt;
&lt;p&gt;win2000中的telnet默认仅以NTLM方式验证身份，这就让我们不得不关注NTLM这个东东，那么什么是NTLM呢？&lt;/p&gt;
&lt;p&gt;早期的&lt;a href=&#34;https://baike.baidu.com/item/SMB%E5%8D%8F%E8%AE%AE/3770892&#34;&gt;SMB协议&lt;/a&gt;在网络上明文传输口令，后来出现了&amp;quot;LAN Manager Challenge/Response&amp;quot;验证机制，简称LM，它十分简单以至很容易被破解，&lt;a href=&#34;https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF&#34;&gt;微软&lt;/a&gt;随后提出了WindowsNT挑战/响应验证机制，即NTLM。现在已经有了更新的NTLMv2以及Kerberos验证体系。看看百度telnet&lt;/p&gt;
&lt;h2 id=&#34;pop&#34;&gt;pop&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;明文传输&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns&#34;&gt;DNS&lt;/h2&gt;
&lt;h1 id=&#34;web常用&#34;&gt;web常用&lt;/h1&gt;
&lt;h2 id=&#34;websocket&#34;&gt;websocket&lt;/h2&gt;
&lt;p&gt;可在单个TCP连接上进行全双工通信，&lt;strong&gt;依赖于&lt;/strong&gt;TCP。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.runoob.com/wp-content/uploads/2016/03/ws.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：ws和http兼容，将http改改格式就是ws协议&lt;/em&gt;？还是说一开始要用http协议握手，然后 传输 不用http?http握手和tcp握手有啥区别？为什么不直接用tcp握手，难道为了兼容就必须使用http?或是说本来设计的就是要用http?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 没有同源限制，客户端可以与任意服务器通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; TCP是传输层？，传数据用TCP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; ws的格式又是什么？&lt;/p&gt;
&lt;p&gt;注意：虽然HTTP/2也具备服务器推送功能，但HTTP/2 只能推送静态资源，无法推送指定的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba526e239afd4693b4ce6e21e2de3d7d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个典型的Websocket握手请求如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务器回应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Connection 必须设置 Upgrade，表示客户端希望连接升级。&lt;/li&gt;
&lt;li&gt;Upgrade 字段必须设置 Websocket，表示希望升级到 Websocket 协议。&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算 SHA-1 摘要，之后进行 BASE-64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，可以尽量避免普通 HTTP 请求被误认为 Websocket 协议。&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Version 表示支持的 Websocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。&lt;/li&gt;
&lt;li&gt;Origin 字段是可选的，通常用来表示在浏览器中发起此 Websocket 连接所在的页面，类似于 Referer。但是，与 Referer 不同的是，Origin 只包含了协议和主机名称。&lt;/li&gt;
&lt;li&gt;其他一些定义在 HTTP 协议中的字段，如 Cookie 等，也可以在 Websocket 中使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先， Sec-WebSocket-Key 是一个 Base64 encode 的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠我，我要验证你是不是真的是 WebSocket 助理。&lt;/p&gt;
&lt;p&gt;然后， Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同 URL 下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦~&lt;/p&gt;
&lt;p&gt;最后， Sec-WebSocket-Version 是告诉服务器所使用的 WebSocket Draft （协议版本），在最初的时候，WebSocket 协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么 Firefox 和 Chrome 用的不是一个版本之类的，当初 WebSocket 协议太多可是一个大难题。。不过现在还好，已经定下来啦~大家都使用同一个版本： 服务员，我要的是13岁的噢→_→&lt;/p&gt;
&lt;p&gt;然后服务器会返回下列东西，表示已经接受到请求， 成功建立 WebSocket 啦！&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;HTTP/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;101&lt;/span&gt; Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里开始就是 HTTP 最后负责的区域了，告诉客户，我已经成功切换协议啦~&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;Upgrade: websocket
Connection: Upgrade
复制代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;依然是固定的，告诉客户端即将升级的是 WebSocket 协议，而不是 mozillasocket，lurnarsocket 或者 shitsocket。&lt;/p&gt;
&lt;p&gt;然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key 。 服务器：好啦好啦，知道啦，给你看我的 ID CARD 来证明行了吧。&lt;/p&gt;
&lt;p&gt;后面的， Sec-WebSocket-Protocol 则是表示最终使用的协议。&lt;/p&gt;
&lt;p&gt;至此，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行了。&lt;/p&gt;
&lt;p&gt;总结，&lt;strong&gt;WebSocket连接的过程是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；&lt;/p&gt;
&lt;p&gt;然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；&lt;/p&gt;
&lt;p&gt;最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。&lt;/p&gt;
&lt;p&gt;WebSocket协议规范将&lt;strong&gt;ws&lt;/strong&gt;（WebSocket）和&lt;strong&gt;wss&lt;/strong&gt;（WebSocket Secure）定义为两个新的统一资源标识符（URI）方案，分别对应&lt;strong&gt;明文&lt;/strong&gt;和&lt;strong&gt;加密&lt;/strong&gt;连接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;节选自wiki&lt;/strong&gt;
RFC 6455中规定：it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries
（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。
为了实现兼容性，WebSocket握手使用HTTP Upgrade头，从HTTP协议更改为WebSocket协议。&lt;/p&gt;
&lt;p&gt;WebSocket协议支持Web浏览器（或其他客户端应用程序）与Web服务器之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。
服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。
通过这种方式，可以在客户端和服务器之间进行双向持续对话。
通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。&lt;/p&gt;
&lt;p&gt;大多数浏览器都支持该协议。
此外，WebSocket还可以在TCP之上实现消息流。TCP单独处理字节流，没有固有的消息概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 消息是数据包？和流是对立的概念？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;常见使用场景：弹幕，网页聊天系统，实时监控（JVM、在线用户、性能等），股票行情推送等&lt;/li&gt;
&lt;li&gt;在浏览器控制台可以输入window.socket查看当前浏览器是否支持websocket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;comet百度百科&lt;/p&gt;
&lt;p&gt;Alex Russell（Dojo Toolkit 的项目 Lead）称这种基于 HTTP&lt;a href=&#34;https://baike.baidu.com/item/%E9%95%BF%E8%BF%9E%E6%8E%A5&#34;&gt;长连接&lt;/a&gt;、无须在浏览器端安装插件的“服务器推”技术为“Comet”。目前已经出现了一些成熟的 Comet 应用以及各种开源框架；一些 Web 服务器如 Jetty 也在为支持大量并发的长连接进行了很多改进。关于 Comet  技术最新的发展状况请参考关于 Comet 的 wiki。&lt;/p&gt;
&lt;p&gt;下面将介绍两种 Comet 应用的实现模型。&lt;/p&gt;
&lt;p&gt;基于 AJAX 的长轮询（long-polling）方式&lt;/p&gt;
&lt;p&gt;如 图 1 所示，AJAX 的出现使得 JavaScript 可以调用 XMLHttpRequest 对象发出 HTTP 请求，JavaScript 响应处理函数根据服务器返回的信息对 HTML 页面的显示进行更新。使用 AJAX 实现“&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8&#34;&gt;服务器推&lt;/a&gt;”与传统的 AJAX 应用不同之处在于：&lt;/p&gt;
&lt;p&gt;服务器端会阻塞请求直到有数据传递或超时才返回。&lt;/p&gt;
&lt;p&gt;客户端JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。&lt;/p&gt;
&lt;p&gt;当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。&lt;/p&gt;
&lt;p&gt;图 2. 基于长轮询的&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8&#34;&gt;服务器推&lt;/a&gt;模型&lt;/p&gt;
&lt;p&gt;一些应用及示例如 “Meebo”, “Pushlet Chat” 都采用了这种长轮询的方式。相对于“&lt;a href=&#34;https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2&#34;&gt;轮询&lt;/a&gt;”（poll），这种长轮询方式也可以称为“拉”（pull）。因为这种方案相对于 AJAX，具有以下一些优点：请求异步发出；无须安装插件；IE、Mozilla FireFox 都支持 AJAX。&lt;/p&gt;
&lt;p&gt;在这种长轮询方式下，客户端是在 XMLHttpRequest 的 readystate 为 4（即数据传输结束）时调用&lt;a href=&#34;https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&#34;&gt;回调函数&lt;/a&gt;，进行信息处理。当 readystate 为 4 时，数据传输结束，连接已经关闭。Mozilla Firefox 提供了对 Streaming AJAX 的支持， 即 readystate 为 3 时（数据仍在传输中），客户端可以读取数据，从而无须关闭连接，就能读取处理服务器端返回的信息。IE 在  readystate 为 3 时，不能读取服务器返回的数据，目前 IE 不支持基于 Streaming AJAX。&lt;/p&gt;
&lt;p&gt;基于 Iframe 及 htmlfile 的流（streaming）方式&lt;/p&gt;
&lt;p&gt;iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的 SRC 属性设为对一个&lt;a href=&#34;https://baike.baidu.com/item/%E9%95%BF%E8%BF%9E%E6%8E%A5&#34;&gt;长连接&lt;/a&gt;的请求，服务器端就能源源不断地往客户端输入数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/pic/comet/10206588/0/f6428f8fc5b5bd9f503d9264?fr=lemma&amp;amp;ct=single&#34;&gt; &lt;img src=&#34;https://bkimg.cdn.bcebos.com/pic/9f2f070828381f308c7d0dfca9014c086e06f07b?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto&#34; alt=&#34;img&#34;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图 3. 基于流方式的&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8&#34;&gt;服务器推&lt;/a&gt;模型&lt;/p&gt;
&lt;p&gt;上节提到的 AJAX 方案是在 JavaScript 里处理 XMLHttpRequest 从服务器取回的数据，然后 Javascript  可以很方便的去控制 HTML 页面的显示。同样的思路用在 iframe 方案的客户端，iframe  服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如“&lt;code&gt;&amp;lt;script  type=&amp;quot;text/javascript&amp;quot;&amp;gt;js_func(“data from server  ”)&amp;lt;/script&amp;gt;&lt;/code&gt;”。服务器端将返回的数据作为客户端JavaScript 函数的&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92&#34;&gt;参数传递&lt;/a&gt;；客户端浏览器的 Javascript 引擎在收到服务器返回的 JavaScript 调用时就会去执行代码。&lt;/p&gt;
&lt;p&gt;从 图 3 可以看到，每次&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81&#34;&gt;数据传送&lt;/a&gt;不会关闭连接，连接只会在通信出现错误时，或是连接重建时关闭（一些防火墙常被设置为丢弃过长的连接， 服务器端可以设置一个超时时间， 超时后通知客户端重新建立连接，并关闭原来的连接）。&lt;/p&gt;
&lt;p&gt;使用 iframe 请求一个&lt;a href=&#34;https://baike.baidu.com/item/%E9%95%BF%E8%BF%9E%E6%8E%A5&#34;&gt;长连接&lt;/a&gt;有一个很明显的不足之处：IE、Morzilla Firefox 下端的进度栏都会显示加载没有完成，而且 IE 上方的图标会不停的转动，表示加载正在进行。Google  的天才们使用一个称为“htmlfile”的 ActiveX 解决了在 IE 中的加载显示问题，并将这种方法用到了 gmail+gtalk  产品中。Alex Russell 在 “What else is burried down in the depth&amp;rsquo;s of Google&amp;rsquo;s amazing JavaScript?”文章中介绍了这种方法。Zeitoun 网站提供的  comet-iframe.tar.gz，封装了一个基于 iframe 和 htmlfile 的 JavaScript comet 对象，支持  IE、Mozilla Firefox 浏览器，可以作为参考。&lt;/p&gt;
&lt;h2 id=&#34;comet的优缺点&#34;&gt;Comet的优缺点&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;&#34;&gt;编辑&lt;/a&gt;&lt;a href=&#34;&#34;&gt; 播报 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;优 点： 实时性好（消息延时小）；性能好（能支持大量用户）&lt;/p&gt;
&lt;p&gt;缺点： 长期占用连接，丧失了无状态高并发的特点。&lt;/p&gt;
&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;p&gt;依赖于tcp&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; http头什么时候发?和tcp头以及websocket头什么区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/gotodsp/p/6366163.html&#34;&gt;https://www.cnblogs.com/gotodsp/p/6366163.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果是默认消息头名称，消息头格式已经固定，即便输入的大小写有误，也会给你翻译成默认的写法，如果自己定义的，会自动给你翻译成小写,所以传参数的名称都用小写字母即可，否则可能取不到值，&lt;/p&gt;
&lt;h3 id=&#34;什么是长连接短连接&#34;&gt;什么是长连接、短连接？&lt;/h3&gt;
&lt;p&gt;在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。&lt;/p&gt;
&lt;p&gt;而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;Connection&lt;/span&gt;:keep-alive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。&lt;/p&gt;
&lt;p&gt;HTTP协议的长连接和短连接，&lt;strong&gt;实质上是TCP协议的长连接和短连接&lt;/strong&gt;。（关不关tcp连接的区别，毕竟是用tcp传输的？）&lt;/p&gt;
&lt;p&gt;由于浏览器中的页面每次需要全部刷新才能从服务器端获得最新的数据或向服务器传送数据，这样产生的延迟所带来的视觉感受非常糟糕。因此很多的桌面应用为了获得更友好的界面放弃了Web技术，或者采用浏览器的插件技术(ActiveX、Applet、Flash等)。但是浏览器插件技术本身又有许多问题，例如跨平台问题和插件版本兼容性问题。&lt;/p&gt;
&lt;p&gt;把 IFrame 嵌在“htmlfile“的 ActiveX 组件中可以解决 IE 的加载显示问题&lt;/p&gt;
&lt;p&gt;曾经建议以X开头的是拓展的Header信息，后来懒得管了doge&lt;/p&gt;
&lt;h3 id=&#34;我见到的http-header信息&#34;&gt;我见到的Http Header信息&lt;/h3&gt;
&lt;h4 id=&#34;代理nginx为例&#34;&gt;代理（nginx为例）&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;例子/描述&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;X-Forwarded-For&lt;/td&gt;
&lt;td&gt;表示 HTTP 路过的ip&lt;/td&gt;
&lt;td&gt;X-Forwarded-For: clientIP, proxy1IP, proxy2IP&lt;/td&gt;
&lt;td&gt;由后一个代理追加前一代理的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Remote Address&lt;/td&gt;
&lt;td&gt;当前HTTP请求的源地址&lt;/td&gt;
&lt;td&gt;tcp连接必须知道源地址，若伪造则无法收到消息&lt;/td&gt;
&lt;td&gt;可用于获取最后一个代理服务器的ip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-Real-IP&lt;/td&gt;
&lt;td&gt;没啥规定&lt;/td&gt;
&lt;td&gt;通常被代理用来表示与它产生 TCP 连接的设备 IP&lt;/td&gt;
&lt;td&gt;也就是设置为Remote Address&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote Address 和 代理服务器追加的X-Forwarded-For（前一个代理或请求端）IP通常是一样的，都是向他发起连接请求端的IP
&lt;ul&gt;
&lt;li&gt;尽管在nginx中不是直接将X-Forwarded-For设置为Remote Address，因为需要“追加”而不是覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端没必要再追加X-Forwarded-For,，它可以通过Remote Address获取不可伪造的上一个代理的ip&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;对于伪造与隐藏&#34;&gt;对于伪造与隐藏：&lt;/h5&gt;
&lt;p&gt;如对于真实ip为114.248.238.236的机器发出的请求，（nginx代理一次，设置x-real-ip为Remote Address，X-Forwarded-For追加 ）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl http://t1.imququ.com:9009/ -H &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;X-Forwarded-For: 1.1.1.1&amp;#39;&lt;/span&gt; -H &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;X-Real-IP: 2.2.2.2&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# nginx代理后服务端输出&lt;/span&gt;
remoteAddress: 127.0.0.1	
x-forwarded-for: 1.1.1.1, 114.248.238.236
x-real-ip: 114.248.238.236
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;伪造&lt;/strong&gt;：可以在发请求时伪造一些header信息，但由于Remote Address 不能伪造，所以x-real-ip和追加的x-forwarded-for是真实ip，之前的部分可以伪造&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏&lt;/strong&gt;：源ip被隐藏在了x-forwarded-for的一个ip中（如果中间没有被改写或是一开始就伪造的话，且可以主动隐藏），其他信息已经被替换成代理服务器的（我主动配置的）&lt;/p&gt;
&lt;p&gt;事实上在这种常用设置下，第一台代理还是知道真实的请求端地址的，服务端可能只知道上一次请求的真实地址；&lt;/p&gt;
&lt;p&gt;伪造后，x-forwarded-for是以为前面还有一台机器（1,1,1,1），，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 那为什么要real ip呢？用偷偷藏起来的自定义ip偷偷保存真实地址么？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看来代理是多进行了几次http连接，作为中介，请求端和服务端的http连接都没有联系对方。&lt;/p&gt;
&lt;p&gt;这也是为什么在nginx上配置跨域比较简单，和请求端沟通始终都是统一个源（代理），他从不同的源获取东西再统一返回。&lt;/p&gt;
&lt;h4 id=&#34;升级为websocket&#34;&gt;升级为websocket&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;例子/描述&lt;/th&gt;
&lt;th&gt;解释/补充&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;websocket&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Upgrade/keep-alive/close&lt;/td&gt;
&lt;td&gt;1.1版本出现，也可用于保持长连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;据说是为了向下兼容，HTTP1.1才正式规范Connection头，之前的协议无法升级；如果是HTTP1.0,不认识Conncetion头，就不升级？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;linux系统中有一个httpd程序，是Apache HTTP服务器程序。直接执行程序可启动服务器的服务，在没有自己安装web服务器软件时可以临时用一下。&lt;/p&gt;
&lt;h1 id=&#34;邮件常用&#34;&gt;邮件常用&lt;/h1&gt;
&lt;p&gt;POP\IMAP负责收，SMTP负责发&lt;/p&gt;
&lt;p&gt;平时我们主要使用网页邮箱，而通过开启IMAP/SMTP服务或POP3/SMTP服务，就可以在其他客户端收发该邮箱的邮件&lt;/p&gt;
&lt;p&gt;在网页邮箱的设置中可以看到POP\IMAP\SMTP的服务器地址（也可以直接百度），将其配置到客户端软件即可（如电脑或手机自带的“邮件”应用）。&lt;/p&gt;
&lt;p&gt;邮箱协议也可以使用SSL加密&lt;/p&gt;
&lt;p&gt;腾讯企业邮箱：&lt;/p&gt;
&lt;p&gt;POP3/SMTP协议&lt;/p&gt;
&lt;p&gt;接收邮件服务器：pop.exmail.qq.com (端口 110)，使用SSL，端口号995
发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465&lt;/p&gt;
&lt;p&gt;IMAP协议&lt;/p&gt;
&lt;p&gt;接收邮件服务器：imap.exmail.qq.com  (端口 143)，使用SSL，端口号993
发送邮件服务器：smtp.exmail.qq.com (端口 25)，使用SSL，端口号465&lt;/p&gt;
&lt;p&gt;我们学校教育邮箱用的腾讯企业邮箱，默认开启了IMAP/SMTP服务，将服务区和端口设置到windows的邮件应用即可使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAP是什么？&lt;/strong&gt;
IMAP，即&lt;strong&gt;I&lt;/strong&gt;nternet &lt;strong&gt;M&lt;/strong&gt;essage &lt;strong&gt;A&lt;/strong&gt;ccess &lt;strong&gt;P&lt;/strong&gt;rotocol（互联网邮件访问协议），您可以通过这种协议从邮件服务器上获取邮件的信息、下载邮件等。IMAP与POP类似，都是一种邮件获取协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAP和POP有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;POP允许电子邮件客户端下载服务器上的邮件，但是您在电子邮件客户端的操作（如：移动邮件、标记已读等），这是不会反馈到服务器上的，比如：您通过电子邮件客户端收取了QQ邮箱中的3封邮件并移动到了其他文件夹，这些移动动作是不会反馈到服务器上的，也就是说，QQ邮箱服务器上的这些邮件是没有同时被移动的 。但是IMAP就不同了，电子邮件客户端的操作都会反馈到服务器上，您对邮件进行的操作（如：移动邮件、标记已读等），服务器上的邮件也会做相应的动作。也就是说，IMAP是“双向”的。&lt;/p&gt;
&lt;p&gt;同时，IMAP可以只下载邮件的主题，只有当您真正需要的时候，才会下载邮件的所有内容。&lt;/p&gt;
&lt;h1 id=&#34;拓展&#34;&gt;拓展&lt;/h1&gt;
&lt;h2 id=&#34;浏览器可以运行的协议&#34;&gt;浏览器可以运行的协议&lt;/h2&gt;
&lt;p&gt;http/https&lt;/p&gt;
&lt;p&gt;file&lt;/p&gt;
&lt;p&gt;ftp&lt;/p&gt;
&lt;h2 id=&#34;其他命令行网络工具无对应协议&#34;&gt;其他命令行网络工具/无对应协议&lt;/h2&gt;
&lt;p&gt;有些在命令行常用的网络工具，使用的协议和命令名没有关联。&lt;/p&gt;
&lt;h3 id=&#34;curl&#34;&gt;curl&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl ip:端口
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可用于测试端口是否联通&lt;/p&gt;
&lt;h3 id=&#34;ping&#34;&gt;ping&lt;/h3&gt;
&lt;p&gt;Linux ping 命令用于检测主机。&lt;/p&gt;
&lt;p&gt;执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。&lt;/p&gt;
&lt;h1 id=&#34;平行的形容词&#34;&gt;平行的形容词&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;实时&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双工？（通信方式？）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有状态？&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连接？&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/ - </description>
        </item>
    
    
    
        <item>
        <title>管理计算机上的软件</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/</link>
        <pubDate>Mon, 23 Aug 2021 16:45:08 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/ -&lt;h1 id=&#34;前置知识&#34;&gt;前置知识&lt;/h1&gt;
&lt;p&gt;代码+文档（bushi）&lt;/p&gt;
&lt;p&gt;装在计算机上的软件，在硬盘上是静态的一系列代码、文件的集合，运行时成为动态的进程；&lt;/p&gt;
&lt;p&gt;但想要保证软件正常运行，需要环境+软件+库/依赖相匹配才行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境：
&lt;ul&gt;
&lt;li&gt;操作系统：基本环境，也是可执行文件的直接运行环境；&lt;/li&gt;
&lt;li&gt;运行环境：如java字节码文件需要运行在jvm里，解释型语言要运行在有解释器的操作系统上，js要在浏览器or Node.js运行一样；似乎都是非纯编译运行的语言需要；在自己的环境中运行，就不需要转换成操作系统的可执行文件；&lt;/li&gt;
&lt;li&gt;java、python等环境安装后，需要将环境的位置添加到操作系统的PATH环境变量中，以确保操作系统能找到他们。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件
&lt;ul&gt;
&lt;li&gt;比程序要大一点的概念，也是一系列指令；&lt;/li&gt;
&lt;li&gt;因此软件最终都会成为机器能看懂的语言，在硬盘上不论是被编译成的可执行文件，还是脚本语言文件（由解释器读入内存一行就解释一行？可能要看看py和js的原理才懂），在cpu接触前，都会成为机器语言；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;库
&lt;ul&gt;
&lt;li&gt;自己的库，如C语言#include的库;Java中的jre就是jvm+基础类库&lt;/li&gt;
&lt;li&gt;系统提供的动态链接库，如win下的dll、linux的lib文件夹内容；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;软件安装方式&#34;&gt;软件安装方式&lt;/h1&gt;
&lt;h2 id=&#34;源码编译&#34;&gt;源码编译&lt;/h2&gt;
&lt;p&gt;下载源代码（如redis使用C语言开发、nginx基于c++开发），然后使用对应版本的编译器（如gcc）在源码文件夹下编译，最终形成可执行文件。为了方便管理，通常会用到项目管理工具如make&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;make 系列命令是GNU下的自由软件，有gcc编译、打包、管理项目（C语言为主，其他语言要调用其他编译/解释器）,和maven类似属于项目管理工具（不知道会不会从网上下载依赖）&lt;/p&gt;
&lt;p&gt;GCC是C/C++语言的编译工具，Make是增量式（编译）批处理工具，CMake是Make脚本生成工具。 在现代C/C++项目的构建中，它们的关系如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;              cmake           make       gcc
CMakelist.txt -----&amp;gt; Makefile ----&amp;gt; Cmds ---&amp;gt; Binary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;在不同cpu架构下源码包和编译器会有区别,因为底层的指令集不同；&lt;/p&gt;
&lt;p&gt;安装流程和C语言源文件运行流程类似&lt;/p&gt;
&lt;h2 id=&#34;安装包&#34;&gt;安装包&lt;/h2&gt;
&lt;p&gt;msi\exe\rpm\ipk\apk\aab;&lt;/p&gt;
&lt;p&gt;安装包也是由源码编译而成的二进制文件；但已经过官方封装，开箱即用。&lt;/p&gt;
&lt;p&gt;单独安装安装包可能会遇到安装包之间的依赖问题。&lt;/p&gt;
&lt;h2 id=&#34;包管理器&#34;&gt;包管理器&lt;/h2&gt;
&lt;p&gt;应用商店等也是类似的角色,在官方的服务器上统一管理安装包;&lt;/p&gt;
&lt;p&gt;apt、yum、rpm、pip、winget等，从源（保管安装包的服务器）上下载安装软件或安装包；可以通过写配置文件等操作来指定多个源；&lt;/p&gt;
&lt;p&gt;一些包管理器可以帮助解决依赖等问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了软件下载外，类似的操作还有maven、nodejs、docker等，对库、包进行管理（包括下载），同时有些具有项目管理功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;npm&#34;&gt;npm&lt;/h3&gt;
&lt;p&gt;npm 是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 &lt;em&gt;包（package）&lt;/em&gt; （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。&lt;/p&gt;
&lt;p&gt;npm 由三个独立的部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网站&lt;/li&gt;
&lt;li&gt;注册表（registry）&lt;/li&gt;
&lt;li&gt;命令行工具 (CLI)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;yarn&#34;&gt;yarn&lt;/h3&gt;
&lt;p&gt;Yarn 是一个软件包管理器，还可以作为项目管理工具。&lt;/p&gt;
&lt;p&gt;代码通过 &lt;strong&gt;软件包（package）&lt;/strong&gt; 的方式被共享。一个软件包里包含了所有需要共享的代码，以及一个描述软件包信息的文件 &lt;code&gt;package.json&lt;/code&gt; （叫做 &lt;strong&gt;清单&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.yarnpkg.cn/getting-started/install&#34;&gt;2 - 安装 | Yarn - JavaScript 软件包管理器 | Yarn 中文文档 - Yarn 中文网 (yarnpkg.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用lockfile隔离单个项目的依赖环境；&lt;/p&gt;
&lt;p&gt;先全局安装yarn的 &lt;strong&gt;二进制文件&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;安装脚本&#34;&gt;安装脚本&lt;/h2&gt;
&lt;p&gt;如docker，网上有提供脚本直接安装;&lt;/p&gt;
&lt;h2 id=&#34;可执行文件脚本文件&#34;&gt;可执行文件/脚本文件&lt;/h2&gt;
&lt;p&gt;可执行文件 (executable file) 指的是可以由&lt;strong&gt;操作系统进行加载执行的文件&lt;/strong&gt;。在不同的操作系统环境下，可执行程序的呈现方式不一样。&lt;/p&gt;
&lt;p&gt;有时被称为“绿色免安装”版，“安装包”其实就是全部程序压缩一下；这种软件安装时不去注册表注册。&lt;/p&gt;
&lt;p&gt;如windows下的exe;&lt;/p&gt;
&lt;p&gt;任何文件都是有数字（编码）组成的，即使是文本在物理上也是以二进制存储的；在一些编辑器下，exe也可以直接被文本编辑器以字符的形式查看。图片、视频也是二进制文件，但不是可执行文件。&lt;/p&gt;
&lt;p&gt;大家都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是&lt;strong&gt;逻辑上&lt;/strong&gt;的。这两者只是在编码层次上有差异。&lt;/p&gt;
&lt;p&gt;可执行文件就是操作系统可以执行的、不需要指定其他软件来执行的文件。一个文件是不是可执行文件要看操作系统的定义。&lt;/p&gt;
&lt;p&gt;pyInstaller可以把py程序打包成exe程序，然后在没有安装python环境的电脑上能运行啦！&lt;/p&gt;
&lt;p&gt;But why MC还需要装java，而不是打包成exe?java应该可以打包吧&lt;/p&gt;
&lt;h1 id=&#34;软件卸载&#34;&gt;软件卸载&lt;/h1&gt;
&lt;h2 id=&#34;管理器控制面板&#34;&gt;管理器/控制面板&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用包管理器的命令卸载&lt;/li&gt;
&lt;li&gt;windows的控制面板:操作系统找到对应的卸载程序并运行;
&lt;ul&gt;
&lt;li&gt;这样似乎对exe直接运行的软件不行;是因为他们没去注册表报道吗?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软件官方提供卸载程序&#34;&gt;软件官方提供卸载程序&lt;/h2&gt;
&lt;p&gt;windows下比较常见，linux可能会提供卸载脚本。&lt;/p&gt;
&lt;h2 id=&#34;可执行文件&#34;&gt;可执行文件&lt;/h2&gt;
&lt;p&gt;直接删除即可；注意不要被快捷方式迷惑了。可以对快捷方式右键-&amp;gt;打开文件位置找到真正的文件所在处。&lt;/p&gt;
&lt;h1 id=&#34;软件运行&#34;&gt;软件运行&lt;/h1&gt;
&lt;p&gt;有些会在内存被更改&lt;/p&gt;
&lt;p&gt;守护进程：占端口号，后台运行&lt;/p&gt;
&lt;p&gt;阻塞进程：会一直占用当前进程/线程&lt;/p&gt;
&lt;h1 id=&#34;附录&#34;&gt;附录&lt;/h1&gt;
&lt;h2 id=&#34;附录1注册表&#34;&gt;附录1：注册表&lt;/h2&gt;
&lt;h2 id=&#34;附录2安装包选择&#34;&gt;附录2：安装包选择&lt;/h2&gt;
&lt;p&gt;x86:适用于字长为32位的计算机；因为在386年代所以叫x86;&lt;/p&gt;
&lt;p&gt;x86_64、arm64：适用于32位和64位的计算机；只是叫法不同（intel和amd）；&lt;/p&gt;
&lt;p&gt;el7:centos7&lt;/p&gt;
&lt;h2 id=&#34;附录3为什么不要安装在中文路径下&#34;&gt;附录3：为什么不要安装在中文路径下？&lt;/h2&gt;
&lt;p&gt;安装目录不要有&lt;strong&gt;中文&lt;/strong&gt;或&lt;strong&gt;空格&lt;/strong&gt;。同一个中文字符在不同字符集下为不同的数值，但大多字符集的前128个字符通常和ASCII字符集保持一致，为了统一且省事，很多软件安装时都不要在中文路径下。&lt;/p&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/ - </description>
        </item>
    
    
    
        <item>
        <title>文件系统</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Thu, 05 Aug 2021 17:07:35 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ -&lt;blockquote&gt;
&lt;p&gt;文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。&lt;/p&gt;
&lt;p&gt;文件系统由三部分组成：文件系统的接口，对对象操作和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ufs联合文件系统&#34;&gt;UFS：联合文件系统&lt;/h1&gt;
&lt;p&gt;Docker使用的系统&lt;/p&gt;
&lt;p&gt;UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。&lt;/p&gt;
&lt;h1 id=&#34;hdfs&#34;&gt;HDFS&lt;/h1&gt;
&lt;p&gt;Hadoop生态系统中的分布式文件系统&lt;/p&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/ - </description>
        </item>
    
    
    
        <item>
        <title>Hugo博客搭建经验</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</link>
        <pubDate>Mon, 26 Jul 2021 16:47:18 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/ -&lt;h1 id=&#34;写在前面&#34;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;​		hugo最强使用技巧：&lt;del&gt;别用hugo&lt;/del&gt;开个玩笑(狗头)&lt;/p&gt;
&lt;p&gt;​		这个世界上的静态网站生成器至少有&lt;a href=&#34;https://jamstack.org/generators/&#34;&gt;333&lt;/a&gt;个，先从我的角度说说其他静态网站生成器的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VuePress：基于vue构建，可以顺便练习vue，减小web开发者的学习成本;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 中文文档&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 主题丰富（在github主页有）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件挺丰富，不知道常用的有没，但是大丈夫！因为是Vue，自己集成功能很方便！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档说是单页应用，解决路由时音乐播放器重新加载播放的问题应该简单一些；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hexo：由中国台湾人创建，咱们用的人多所以网上教程丰富；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[√]中文文档&lt;/li&gt;
&lt;li&gt;[√]主题丰富&lt;/li&gt;
&lt;li&gt;[√]插件齐全（几乎不用敲代码，npm上都一堆插件）&lt;/li&gt;
&lt;li&gt;多个静态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WordPress:嗯。。和hugo都是老外搞的，风格半斤八两，都用了&amp;quot;shortcode&amp;quot;这种奇怪的东西（类似模板引擎或vue的组件，但还需要额外的学习成本），支持OneNote上传笔记（鸡肋）；可以和PHP配套使用；&lt;/p&gt;
&lt;p&gt;然后。。。hugo的优点可能是快？我不知道。。。&lt;del&gt;可我是男人&lt;/del&gt;可如果开发速度慢、学习成本高不还相当于慢了。。中文文档还相当于没有！&lt;/p&gt;
&lt;p&gt;如果重命名content下的md文件，hugo编译时不会把删掉该替换的文件。不知道其他工具怎么样。&lt;/p&gt;
&lt;p&gt;当然所有工具都是没有上限的！只是==碰壁次数与资料多少、学习成本==之类的区别！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;快速开始&#34;&gt;快速开始&lt;/h1&gt;
&lt;p&gt;中文文档少有的中文233：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.gohugo.cn/getting-started/quick-start/&#34;&gt;快速入门 | Hugo 中文网 (gohugo.cn)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中下载主题这步可以自己选，主题商城也在这个网站中↑；&lt;/p&gt;
&lt;p&gt;我所用的主题是Diary，可以在博客左下↙版权那里找到github仓库。自己魔改了一部分，为了添加功能。&lt;/p&gt;
&lt;h1 id=&#34;常用命令脚本&#34;&gt;常用命令、脚本&lt;/h1&gt;
&lt;p&gt;​		获取QQ头像的url:	&lt;code&gt;https://q1.qlogo.cn/g?b=qq&amp;amp;nk=QQ号码&amp;amp;s=640&lt;/code&gt;。用edge浏览器的时候发现，如果用https访问博客，头像url用http访问的话会被拦截。&lt;/p&gt;
&lt;p&gt;​		每次输入这么多命令太麻烦了，hugo似乎没有把自己提交到github的命令，索性写了一个windows脚本上传博客。提前在path环境变量中配置hugo命令所在目录，以在任意位置执行hugo命令。&lt;/p&gt;
&lt;p&gt;​		还是第一次主动写windows脚本，上一次写还是上一次（呸，上次是改U盘图标，照网上抄的）。脚本文件后缀名为.bat，直接在里面写命令即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hugo -D
hugo
&lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; ./public
git add -A
git commit -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;脚本提交&amp;#34;&lt;/span&gt;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​		先执行一遍hugo -D是为了将草稿也编译一下；再不带-D，这样主页不会显示草稿；&lt;/p&gt;
&lt;p&gt;​		还有一个博客生成测试脚本，执行hugo server命令，用于在本地实时查看页面；&lt;/p&gt;
&lt;p&gt;​		也可以使用github Actions来完成持续集成（CI）,顺道学习Devops；难得有个项目有提供hugo的插件，我却还是觉得脚本成本低，，&lt;/p&gt;
&lt;p&gt;进阶版脚本：同时提交至github和gitee:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chcp &lt;span style=&#34;color:#b452cd&#34;&gt;65001&lt;/span&gt;
rem 定义变量延迟环境，关闭回显
@echo off&amp;amp;setlocal enabledelayedexpansion
rem 读取config.toml所有内容
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; /f &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;eol=* tokens=*&amp;#34;&lt;/span&gt; %%i  in (config.toml) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; (
rem 设置变量a为每行内容
&lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;a&lt;/span&gt;=%%i
&lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;a=!a:http://tablerows.gitee.io/tablerow.github.io/=https://baiban114.github.io/tablerow.github.io/!&amp;#34;&lt;/span&gt;
rem 把修改后的全部行存入$
&lt;span style=&#34;color:#658b00&#34;&gt;echo&lt;/span&gt; !a!&amp;gt;&amp;gt;$)
rem 用$的内容替换原来config.toml内容
move $ config.toml

hugo -D
hugo
&lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; ./public
git add -A
git commit -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;脚本提交&amp;#34;&lt;/span&gt;
git push -u origin master

&lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; ..

@echo off&amp;amp;setlocal enabledelayedexpansion
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; /f &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;eol=* tokens=*&amp;#34;&lt;/span&gt; %%i  in (config.toml) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;do&lt;/span&gt; (
&lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;a&lt;/span&gt;=%%i
&lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;a=!a:https://baiban114.github.io/tablerow.github.io/=http://tablerows.gitee.io/tablerow.github.io/!&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#658b00&#34;&gt;echo&lt;/span&gt; !a!&amp;gt;&amp;gt;$)
move $ config.toml

hugo -D
hugo
&lt;span style=&#34;color:#658b00&#34;&gt;cd&lt;/span&gt; ./public
git add -A
git commit -m &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;脚本提交&amp;#34;&lt;/span&gt;
git push -u gitee master
pause
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;chcp 65001是将本次bat脚本运行时采用的字符集设置为utf8，因为牵扯到修改hugo的配置文件（相关内容会编译至页面）&lt;/p&gt;
&lt;p&gt;如果脚本页面中的内容也有中文（如“脚本提交”），建议将也脚本文件保存为utf8,避免这一部分中文变成乱码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 回头试试提交信息加上时间戳之类的（或者指定参数？）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;自己钻研的定制经验&#34;&gt;自己钻研的定制经验&lt;/h1&gt;
&lt;p&gt;utteranc.es客户端地址：https://utteranc.es/client.js&lt;/p&gt;
&lt;p&gt;​		因为没时间系统学习怎么制作hugo主题，我只能在Diary主题的基础上瞎摸索，这里是一些经验；如果其他主题作者命名方式一样（约定大于配置233）就会很好办。&lt;/p&gt;
&lt;p&gt;​		对Diary主题改动了一些，有点儿想提PR的冲动。。。不过萌新经验还差太多，不知道合不合适。。。羞(．． )…&lt;/p&gt;
&lt;h2 id=&#34;站点主题目录结构&#34;&gt;站点&amp;amp;&amp;amp;主题目录结构&lt;/h2&gt;
&lt;p&gt;根站点和主题文件夹有相同的目录结构，hugo会优先使用根站点下的配置。&lt;/p&gt;
&lt;p&gt;以Diary为例，主题根文件夹下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;layout放置了页面的主体框架，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shortcodes目录定义shortcode，可以在其他html中当组件用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_default下存放了主体部分的html框架（即body中的主div内的内容，正中间的主体）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;baseof.html是全html页面的框架，其中head部分被放到了partials文件夹下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;single.html是文章内容的html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以自定义友链、“关于我”这种功能的页面在这里，记得将single中的主体框架部分拷贝过来，修改{{.Content}}附近；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;踩坑：自定义页面的时候，要全用{{define main}}包裹起来，我把css放在外边，结果只编译了css&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partials有评论、head、自定义head、版权、主体js等部分的html&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sidebar:电脑端侧边栏的大纲（说是大纲是因为引用了版权页，而版权页单独写在一个html里），移动端这部分有单独页面，不在这里（见baseof.html）；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data 存储数据文件供模板使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;public&lt;/em&gt; 生成的静态网站文件会放在这里&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;站点配置文件configtoml&#34;&gt;站点配置文件config.toml&lt;/h2&gt;
&lt;p&gt;注意不要在主题文件夹下放config！那儿也会生效！&lt;/p&gt;
&lt;h2 id=&#34;博文开头的元数据配置&#34;&gt;博文开头的元数据配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;layout: &amp;quot;&amp;quot;	不用带后缀；该md文件会寻找layout下同名html文件渲该页染；&lt;/li&gt;
&lt;li&gt;draft: true   为true时是草稿，不带-D参数的hugo命令不会编译、在首页显示草稿；这也是为什么我要在脚本里先后执行两次命令。
&lt;ul&gt;
&lt;li&gt;关于我、友链等页面可以用这种方式从隐藏，只在特定页面出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他的可以见主题文件夹下/archetypes/default.md&lt;/p&gt;
&lt;h1 id=&#34;拓展&#34;&gt;拓展&lt;/h1&gt;
&lt;h2 id=&#34;评论插件&#34;&gt;评论插件&lt;/h2&gt;
&lt;p&gt;静态博客要是没有自己的后台的话，评论也只能托管到其他平台上去。我用的是utteranc.es，客户端地址：https://utteranc.es/client.js&lt;/p&gt;
&lt;p&gt;是将评论套在github的评论区。缺点是要在国内登录github网不好。。也许有gitee的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 或者自己写个类似的直接评论到B站这类平台？会爬虫or bot应该不难。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有很多其他的评论插件更好，但我忘了名字了doge在这里记一下。真不推荐我用的这个。虽然有些平台要带水印之类的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gittalk&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;live2d看板娘&#34;&gt;Live2d看板娘&lt;/h2&gt;
&lt;h3 id=&#34;基础款&#34;&gt;基础款&lt;/h3&gt;
&lt;p&gt;​		基础款&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/javascript&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;charset&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/live2d-widget@3.1.4/lib/L2Dwidget.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;text/javascript&amp;#34;&lt;/span&gt;&amp;gt;
    L2Dwidget.init({
        model: {
            scale: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,
            hHeadPos: &lt;span style=&#34;color:#b452cd&#34;&gt;0.5&lt;/span&gt;,
            vHeadPos: &lt;span style=&#34;color:#b452cd&#34;&gt;0.618&lt;/span&gt;,
            jsonPath: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;https://cdn.jsdelivr.net/npm/live2d-widget-model-hibiki@1.0.5/assets/shizuku.model.json&amp;#39;&lt;/span&gt;,       &lt;span style=&#34;color:#228b22&#34;&gt;// xxx.model.json 的路径,换人物修改这个
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        },
        display: {
            superSample: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,     &lt;span style=&#34;color:#228b22&#34;&gt;// 超采样等级
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            width: &lt;span style=&#34;color:#b452cd&#34;&gt;120&lt;/span&gt;,         &lt;span style=&#34;color:#228b22&#34;&gt;// canvas的宽度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            height: &lt;span style=&#34;color:#b452cd&#34;&gt;300&lt;/span&gt;,        &lt;span style=&#34;color:#228b22&#34;&gt;// canvas的高度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            position: &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;right&amp;#39;&lt;/span&gt;,   &lt;span style=&#34;color:#228b22&#34;&gt;// 显示位置：左或右
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            hOffset: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,         &lt;span style=&#34;color:#228b22&#34;&gt;// canvas水平偏移
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            vOffset: &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;,         &lt;span style=&#34;color:#228b22&#34;&gt;// canvas垂直偏移
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        },
        mobile: {
            show: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;,         &lt;span style=&#34;color:#228b22&#34;&gt;// 是否在移动设备上显示
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            scale: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,           &lt;span style=&#34;color:#228b22&#34;&gt;// 移动设备上的缩放
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            motion: &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;,       &lt;span style=&#34;color:#228b22&#34;&gt;// 移动设备是否开启重力感应
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        },
        react: {
            opacityDefault: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,  &lt;span style=&#34;color:#228b22&#34;&gt;// 默认透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            opacityOnHover: &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,  &lt;span style=&#34;color:#228b22&#34;&gt;// 鼠标移上透明度
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        },
     });
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;加到哪儿应该都行，我是粘到了extended_head里，这样会加载到head标签中。人物长什么样子可以直接百度“live2d 看板娘 ”+名字、长相什么的。我个人喜欢shizuku，双马尾好可爱ヽ(✿ﾟ▽ﾟ)ノ!!!  hibiki也不错&lt;/p&gt;
&lt;h2 id=&#34;音乐插件&#34;&gt;音乐插件&lt;/h2&gt;
&lt;p&gt;使用了APlayer &amp;amp;&amp;amp; MetingJS。直接看MetingJS的github仓库即可：&lt;a href=&#34;https://github.com/metowolf/MetingJS&#34;&gt;MetingJS&lt;/a&gt;，暂时不用看Aplayer用法，CV大法好（doge）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;link&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rel&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;stylesheet&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;href&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;src&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!-- 放在想生成播放器的地方⬇ --&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;meting-js&lt;/span&gt;
	&lt;span style=&#34;color:#658b00&#34;&gt;server&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;netease&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;playlist&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#658b00&#34;&gt;id&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;					
	&lt;span style=&#34;color:#658b00&#34;&gt;list-folded &lt;/span&gt;= &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;	
	&lt;span style=&#34;color:#658b00&#34;&gt;volume &lt;/span&gt;= &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0.3&amp;#34;&lt;/span&gt;			
&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;meting-js&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aplay是一个Html5音乐播放器，而MetingJS结合了国内几大音乐平台的api。本想直接用外链，但网易云官方现在似乎不提供可用的歌单外链。&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在使用Meting提供的网易云api时，歌单里歌曲太多或使用“我喜欢的音乐”歌单可能无法从api获取数据！&lt;/li&gt;
&lt;li&gt;需要的js、css文件在头文件中&lt;code&gt;按顺序&lt;/code&gt;引入（有依赖关系）&lt;/li&gt;
&lt;li&gt;Aplayer官方提出了好多静态博客插件，唯独没有hugo的。~~《如果早知道，用hugo会被孤立。。。》~~虽然我也没用那些插件。这个主题用了vue，可以通过vue集成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;静态页面托管平台&#34;&gt;静态页面托管平台&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;github pages&lt;/li&gt;
&lt;li&gt;gitee pages
&lt;ul&gt;
&lt;li&gt;提交到仓库后，还要在Pages服务那里点“更新”才会更新！！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vercel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我看oschina和CSDN也有项目仓库了，不知道有没有托管功能。&lt;/p&gt;
&lt;h1 id=&#34;图床&#34;&gt;图床&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;gitee
&lt;ul&gt;
&lt;li&gt;对于常用图片后缀不允许外链（通过查看请求头中的Refer）,目前webp格式的还可以。如果只把博客部署在gitee还是可以考虑&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 能不能钻个空子利用pages当图床?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CSDN发篇文章只有图片当图床&lt;/li&gt;
&lt;li&gt;vercel + 百度云&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;我为什么用hugo&#34;&gt;我为什么用hugo?&lt;/h1&gt;
&lt;p&gt;​	哦我的上帝啊，瞧瞧这hugo！ko no sei gai还有更难用的静态网站生成器吗？当然我也没用过其他的，只是吐槽一下hhh&lt;/p&gt;
&lt;p&gt;​	一开始尝试在centos7上使用hugo（linux64位0.84.x版本），并用nginx做服务器部署生成的静态页面，遇到了路径问题，样式文件加载不出来；然后修改到一半，新的页面突然就生不出来了。。。QAQ&lt;/p&gt;
&lt;p&gt;​	改了配置文件、添加了新文章、执行hugo命令后也没有生成新的、正确的静态页面。根据提示，安装extended版本 ，结果又报错说缺少c++的新版动态库，但我的确是新版了（跟CSDN上的博客比）。现在有经验了，回想回想可能是配置文件或者命令错了。&lt;/p&gt;
&lt;p&gt;​		最后用了windows版+github pages。省时又省心，效果还一样。之前尝试部署到服务器上的我简直是个可爱的小傻瓜。&lt;/p&gt;
&lt;p&gt;​		另，gitee的Pages服务这几个月关闭了，预计8月左右恢复。说是为了建设绿色网络环境什么的，可能不符合规定的要被清除？&lt;/p&gt;
&lt;p&gt;​		近日正好收到一篇公众号的推送，是关于hugo搭建博客的，就用上了。最早了解的是wordPress，但没有使用；身边人用的最多的是hexo。年轻时总想着搞个人博客，早就接触到了建站容易的静态博客，但感觉搭建起来对技术提高帮助不大，就没搞。&lt;/p&gt;
&lt;p&gt;​		现在博客做起来了，能刺激我总结总结经验知识。通过添加各种前端特效、插件，巩固了一下前端基础。这些可以做刚学完前端基础的过渡练习，要是那会儿就来实战练习就好了。那会儿天天做作业，贼枯燥，做完还就扔了忘了，没实战也没效率(* ￣︿￣)&lt;/p&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/ - </description>
        </item>
    
    
    
        <item>
        <title>tips</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/tips/</link>
        <pubDate>Sat, 24 Jul 2021 18:06:08 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/tips/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/tips/ -&lt;p&gt;数学嘛，又不是主业，实用的该用时想起来就好，其他的看兴趣啦~高中我不都是按兴趣学的嘛~&lt;/p&gt;
&lt;h1 id=&#34;考研数学&#34;&gt;考研数学&lt;/h1&gt;
&lt;h2 id=&#34;出题套路&#34;&gt;出题套路&lt;/h2&gt;
&lt;p&gt;加过来减过去；四则运算；没思路时先试试&lt;/p&gt;
&lt;p&gt;2020把加减又变成大于小于；&lt;/p&gt;
&lt;h2 id=&#34;张宇高数第一讲&#34;&gt;张宇高数第一讲&lt;/h2&gt;
&lt;p&gt;等式 =&amp;gt; 两边取极限、倒数、积分、同乘同除同加减、取对数，换位置，目的是得到想要的。&lt;/p&gt;
&lt;p&gt;出题套路 =&amp;gt; 改变数字顺序，把本来该在一起的拆开(例1.1)；有些将来会被消掉，不用怕。&lt;/p&gt;
&lt;p&gt;换元：无法拆开的xt、x-t等换元。比如f(xt)&lt;/p&gt;
&lt;p&gt;数形结合百般好；别光给哪儿捯饬等式，画图啊！看看性状面积啥的&lt;/p&gt;
&lt;h2 id=&#34;第二讲&#34;&gt;第二讲&lt;/h2&gt;
&lt;p&gt;已知不等式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sinx &amp;lt;= x；sinx其实比x小，看泰勒展开式就知道；同济书里的证明：&lt;img src=&#34;https://img-blog.csdnimg.cn/20201117164621931.png&#34; alt=&#34;alt&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例2.13：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gitee.com/tablerows/tianrun/raw/master/imgs/20210802172809.png&#34; alt=&#34;image-20210802172757774&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第四讲之前&#34;&gt;第四讲之前&lt;/h2&gt;
&lt;p&gt;奇奇得偶；奇函数泰勒展开不会有偶数次方；&lt;/p&gt;
&lt;h1 id=&#34;辞典&#34;&gt;辞典&lt;/h1&gt;
&lt;h2 id=&#34;懒加载&#34;&gt;懒加载&lt;/h2&gt;
&lt;h3 id=&#34;webload-on-demand&#34;&gt;web:load on demand&lt;/h3&gt;
&lt;p&gt;需要时才于后端交互（如百度图片下拉显示更多）。缓存虽然能一定程度上解决访问后端较慢的问题，但缓存不能存大量数据。&lt;/p&gt;
&lt;h3 id=&#34;javalazy-load&#34;&gt;java：Lazy load&lt;/h3&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/tips/ - </description>
        </item>
    
    
    
        <item>
        <title>灵鸡一动</title>
        <link>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/</link>
        <pubDate>Wed, 21 Jul 2021 05:37:27 +0800</pubDate>
        
        <guid>http://tablerows.gitee.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/</guid>
        <description>彦祖，你又来了 http://tablerows.gitee.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/ -&lt;blockquote&gt;
&lt;p&gt;使用次数少的（比如安装软件，也没遇到意外情况）就不需要记录了。相同主题整理的多了要考虑拆分，像分库分表一样。&lt;/p&gt;
&lt;p&gt;知识类分三档：死记硬背的、理解的、容易忘也不好整理进体系的小tips。本页记录理解档内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识内容都是自己的理解，要时长更新纠错&lt;/p&gt;
&lt;p&gt;标题灵感来自高中物理老师ᕕ( ᐛ )ᕗ&lt;/p&gt;
&lt;h1 id=&#34;老生常谈的概念&#34;&gt;老生常谈的概念&lt;/h1&gt;
&lt;h2 id=&#34;动态和静态&#34;&gt;动态和静态&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;动态&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;静态&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;出处|例子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;运行时、在内存中==结构==可变的&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译后确定，&lt;strong&gt;运行时不可变的&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动/静语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;随数据而变的&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写死的文件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动态页面，动/静态服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;被调度、分配资源、随运行时环境而改变；上下文/命名空间等限制&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;程序、作业、镜像&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;操作系统、Docker&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;应该雀食哈，动态才有状态转换的概念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见概念：线性、连续、离散、顺序、索引、链式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;物理存储上的概念&#34;&gt;物理存储上的概念：&lt;/h2&gt;
&lt;p&gt;这四项在逻辑结构中也有对应的表：顺序表（数组）、链表、索引表、哈希表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个接一个的，连续的，有序的（唯一前驱和后缀关系）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;顺序&#34;&gt;顺序&lt;/h2&gt;
&lt;p&gt;顺序存储指的是，集合里面的元素都是按照次序排列在一块连续的存储空间中；&lt;/p&gt;
&lt;p&gt;在文件中的话&lt;/p&gt;
&lt;p&gt;顺序文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优势:读、写一大批记录&lt;/li&gt;
&lt;li&gt;缺点： 查找、修改、增加、删除单条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;
&lt;p&gt;建立索引表，从索引表直接读取地址&lt;/p&gt;
&lt;p&gt;文件结构的索引表是定长记录的顺序文件&lt;/p&gt;
&lt;h2 id=&#34;逻辑结构上的概念&#34;&gt;逻辑结构上的概念&lt;/h2&gt;
&lt;p&gt;分为线性和非线性&lt;/p&gt;
&lt;h3 id=&#34;线性&#34;&gt;线性：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;感觉真的像一条线上的关系；&lt;/p&gt;
&lt;p&gt;是连续的么？和离散是什么关系？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;线性关系&#34;&gt;线性关系：&lt;/h6&gt;
&lt;p&gt;​	两个变量之间存在一次方&lt;a href=&#34;https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB/9846826&#34;&gt;函数关系&lt;/a&gt;，就称它们之间存在线性关系。&lt;a href=&#34;https://baike.baidu.com/item/%E6%AD%A3%E6%AF%94%E4%BE%8B%E5%85%B3%E7%B3%BB/8192987&#34;&gt;正比例关系&lt;/a&gt;是线性关系中的特例，&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%8D%E6%AF%94%E4%BE%8B%E5%85%B3%E7%B3%BB/8193245&#34;&gt;反比例关系&lt;/a&gt;不是线性关系。&lt;/p&gt;
&lt;p&gt;​	&lt;em&gt;反比例关系：两个变量乘积不变&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​	如果把这两个变量分别作为点的横坐标与纵坐标，其图象是平面上的一条直线，则这两个变量之间的关系就是线性关系。即如果可以用一个二元一次方程来表达两个变量之间关系的话，这两个变量之间的关系称为线性关系，因而，二元一次方程也称为线性方程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学里，一般说的线性，是说的线性映射，这是一个函数（或称为映射，function or map），而不是方程 (equation)。&lt;/p&gt;
&lt;p&gt;这个映射要同时满足两个条件：&lt;/p&gt;
&lt;p&gt;1，可加性 f(x + y) = f(x) + f(y)&lt;/p&gt;
&lt;p&gt;2，齐次性（同质性） f(αx) = αf(x)&lt;/p&gt;
&lt;p&gt;也有用 叠加特性：f(ax+by)=af(x)+bf(y) 合起来表示的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;这个齐次性放在齐次线性方程怎么理解？（我连名字都不一定记准。。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;数据结构上：一对一的关系&lt;/p&gt;
&lt;h6 id=&#34;线性的例子&#34;&gt;线性的例子&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;线性表：最基本的是：
&lt;ul&gt;
&lt;li&gt;数组（顺序表）：下标和元素一一对应，可随机存取：随便选一个位置存取&lt;/li&gt;
&lt;li&gt;链表：唯一前缀唯一后继;查找、表的合并不便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;非线性&#34;&gt;非线性&lt;/h6&gt;
&lt;p&gt;树、图，一对多或多对多&lt;/p&gt;
&lt;h6 id=&#34;线性代数中学到的&#34;&gt;线性代数中学到的&lt;/h6&gt;
&lt;p&gt;行列式中两个向量可以互相表示，说明他们是&lt;strong&gt;线性相关&lt;/strong&gt;的(行列式得0，因为向量平行)&lt;/p&gt;
&lt;h2 id=&#34;流批&#34;&gt;流批！&lt;/h2&gt;
&lt;p&gt;仅理解概念用；有的是批处理命令，有的是批处理作业&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;流、流处理&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;批&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;出处or举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流水一样源源不断的；来一个搞一个&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;先攒一批，一次搞一批；&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Mybatis流式查询（可实现分页）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一般需要注意open和close&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;有些不处理完一批不停&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符流、字节流、IO流、代码流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;联机命令接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;脱机命令接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;操作系统/win脚本（批处理）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;流式文件-无结构&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;（感觉记录式文件和批的概念没相似之处）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;联机命令接口：命令行的方式，又叫交互模式；批处理模式，又叫脚本模式&lt;/p&gt;
&lt;p&gt;一批里也是一个一个来的，而不是一“个”作业；一批看作一个整体；抢占式是不是可以先让一批停下来？&lt;/p&gt;
&lt;h2 id=&#34;抽象与具体&#34;&gt;抽象与具体&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;抽象&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;具体&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;出处or举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只有概念没有实体&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实体&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;类和对象/抽象函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;云计算&#34;&gt;云计算&lt;/h1&gt;
&lt;p&gt;（cloud computing）是分布式计算的一种，通过网络“云”将计算处理程序分解成小程序计算。（有点儿像分治？mapreduce?）&lt;/p&gt;
&lt;h2 id=&#34;云计算三种服务模式&#34;&gt;云计算三种服务模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IaaS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SaaS：(Software as a Service)通过网络进行程序提供的服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PaaS:（Platform as a Service）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是指&lt;a href=&#34;https://baike.baidu.com/item/%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1/4329761&#34;&gt;平台即服务&lt;/a&gt;。  把服务器平台作为一种服务提供的商业模式，以SaaS的模式提交给用户。因此，PaaS也是&lt;a href=&#34;https://baike.baidu.com/item/SaaS&#34;&gt;SaaS&lt;/a&gt;模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度(位于中间件层，提供企业进行定制化研发的中间件平台、数据库、应用服务器等)。&lt;/li&gt;
&lt;li&gt;在2007年国内外SaaS厂商先后推出自己的PAAS平台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在云计算范围内（分布式、网络）考虑这仨的概念！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cloud Foundry是业界第一个开源PaaS云平台。诞生了“容器”？由Vmware小组开发&lt;/p&gt;
&lt;p&gt;而Docker打包时带上了环境（操作系统的rootfs，很小，内核直接用宿主机的），不用再在另一台机器的配置上麻烦。但单独的docker只是部署小项目的小工具，用容器编排(Docker Compose)和容器集群才算提供Paas。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单个容器的应用肯定不足以支撑项目，不用集群用不了分布式、云计算？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;猜想&#34;&gt;猜想&lt;/h1&gt;
&lt;h2 id=&#34;用于联系的数学公式&#34;&gt;用于联系的数学公式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可根据提供的条件互相转化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数列与极限：归结原则&lt;/p&gt;
&lt;p&gt;拉格朗日中值定理：连接f与f`&lt;/p&gt;
&lt;p&gt;连续连接函数与导数（还有极限）&lt;/p&gt;
&lt;h1 id=&#34;充要条件们&#34;&gt;充要条件们&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;函数值存在 &amp;lt;=&amp;gt; 该点极限存在&lt;/li&gt;
&lt;li&gt;可导 &amp;lt;=&amp;gt; 左导数等于右导数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据库离散数学文件系统oop&#34;&gt;数据库、离散数学、文件系统、OOP&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据库&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;离散数学&lt;/th&gt;
&lt;th&gt;文件系统&lt;/th&gt;
&lt;th&gt;OOP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;某种属性的，是数据中可命名的最小逻辑数据单位&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td&gt;数据项&lt;/td&gt;
&lt;td&gt;成员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据项的集合&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;记录；行&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;元组？&lt;/td&gt;
&lt;td&gt;记录（定长、可变长）&lt;/td&gt;
&lt;td&gt;对象、类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;实体表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td&gt;记录式文件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;系统调用&#34;&gt;系统调用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;文件
&lt;ul&gt;
&lt;li&gt;open:
&lt;ul&gt;
&lt;li&gt;将指明文件的属性（包括在外存的物理位置）从外存复制到内存==打开文件表==的一个表目中，&lt;/li&gt;
&lt;li&gt;同时返回索引（王道又说是指针？编号？），以后就操作指针&lt;/li&gt;
&lt;li&gt;打开计数器&lt;code&gt;++&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;控制块&#34;&gt;控制块&lt;/h1&gt;
&lt;h2 id=&#34;文件控制块fcb&#34;&gt;文件控制块FCB&lt;/h2&gt;
&lt;h2 id=&#34;进程控制块pcb&#34;&gt;进程控制块PCB&lt;/h2&gt;
&lt;h2 id=&#34;作业控制块jcb&#34;&gt;作业控制块JCB&lt;/h2&gt;
&lt;h1 id=&#34;控制反转依赖注入&#34;&gt;控制反转&amp;amp;&amp;amp;依赖注入&lt;/h1&gt;
&lt;p&gt;控制权不是代码；可以从配置文件向代码注入值；方法是IO；修改时不用改代码，修改文件即可；适合搞配置&lt;/p&gt;
- http://tablerows.gitee.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/ - </description>
        </item>
    
    
  </channel>
</rss> 