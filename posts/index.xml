<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 彦祖，你又来了</title>
    <link>https://baiban114.github.io/tablerow.github.io/posts/</link>
    <description>Recent content in Posts on 彦祖，你又来了</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 09 Apr 2022 18:53:28 +0800</lastBuildDate><atom:link href="https://baiban114.github.io/tablerow.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>网络寻址</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/</link>
      <pubDate>Sat, 09 Apr 2022 18:53:28 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AF%BB%E5%9D%80/</guid>
      <description>套接字 URL URL（统一资源定位符）是Internet上资源的地址，可以定义为引用地址的字符串，用于指示资源的位置以及用于访问它的协议。
URL是在网络上定位资源的最普遍使用的方式，它提供了一种通过描述其网络位置或主要访问机制来检索物理位置的表示的方法。
URL中描述了协议，该URL用于检索资源和资源名称。如果资源是Web类型资源，则URL在开头包含http / https。同样，如果资源是文件，则以ftp开头，如果资源是电子邮件地址，则以mailto开头。
URL包含以下信息：
1、用于访问资源的协议
2、服务器的位置（无论是通过IP地址还是域名）
3、服务器上的端口号（可选）
4、资源在服务器目录结构中的位置
5、片段标识符（可选）
 端口是只在http默认80还是？  例：https://blog.csdn.net/qq_44915801
 URL中有些字符不能出现，有些是有其他含义，比如&#39;+&#39;。想要再url中使用这些符号，可以使用他们的编码，比如数据库连接的url中设置时区的”GMT+8“可以写作”GMT%2B8“
 URI URI（统一资源标识符）是标识逻辑或物理资源的字符序列，与URL类似，也是一串字符。通过使用位置，名称或两者来标识Internet上的资源；它允许统一识别资源。
有两种类型的URI，统一资源标识符（URL）和统一资源名称（URN）。
任何URI的通用形式都是：
scheme：[// [user：password @] host [：port]] [/] path [？查询] [#片段]
Scheme（方案）：该方案列出了具体语法和URI的任何相关协议。方案不区分大小写，后跟冒号。理想情况下，URI方案应该在互联网号码分配机构（IANA）注册，但也可以使用非注册方案。
权限组件：权限组件由多个部分组成：可选的身份验证部分，主机（由注册名称或IP地址组成） , 以及可选的端口号。身份验证部分包含用户名和密码，用冒号分隔，后跟at（@）符号。在@之后是主机名，然后是冒号，然后是一个端口号。请务必注意，IPv4地址必须采用点十进制表示法，并且IPv6地址必须括在括号中。
查询（可选）：查询包含一串非分层数据。虽然语法没有明确定义，但通常是由分隔符分隔的属性值对序列，例如＆符号或分号。查询通过问号与前一部分分开。
片段（可选）：片段包含片段标识符，该标识符为辅助资源提供方向。
URL和URI之间的主要区别
URL是统一资源定位器，用于标识资源；URI（统一资源标识符）提供了更简单和可扩展的标识资源的方法。URL是URI的子集
1、作用的区别
URL（统一资源定位符）主要用于链接网页，网页组件或网页上的程序，借助访问方法（http，ftp，mailto等协议）来检索位置资源。
URI（统一资源标识符）用于定义项目的标识，此处单词标识符表示无论使用的方法是什么（URL或URN），都要将一个资源与其他资源区分开来。
2、可以说URL是URI（URL是URI的子集），但URI永远不能是URL。
3、协议区别
URL指定要使用的协议类型，而URI不涉及协议规范。</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 11 Jan 2022 21:53:15 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式的六大原则 1、开闭原则（Open Close Principle）
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3、依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
5、迪米特法则，又称最少知道原则（Demeter Principle）
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
创建型模式 工厂模式（Factory Pattern） 接口Factory直接对应接口（接口指向实现类）？
抽象工厂模式 工厂对简单工厂多一层抽象，抽象工厂再多一层
   模式      简单工厂（非23） 具体工厂，生产产品   工厂 工厂类有统一接口，生产一类产品（鼠标；颜色）   抽象工厂 同类工厂每个厂可以生产多个产品，或一个产品可以多种品牌    总之就是接口向上提了一层，类似多级索引或多维数组，多一层就多了一种可能（系统太复杂了加一层？）
   产品 工厂     耳麦接口 工厂接口内加入生产耳麦方法   实现戴尔耳麦、惠普耳麦 实现惠普工厂、戴尔工厂，实现生产方法    FactoryProducer不变（若加入新品牌华为就改改）</description>
    </item>
    
    <item>
      <title>应用层网络协议</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sat, 28 Aug 2021 16:16:32 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E5%BA%94%E7%94%A8%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</guid>
      <description>网络协议：约定的信息传输的格式，如几个字节是消息头、消息头记录什么信息之类的； c/s架构：不一定是两台计算机，而是两个应用、两个端口 工具：实际使用中不用手动封装协议再发消息，而是直接使用封装的软件、库等实现功能。如SSH工具OpenSSH  命令行常用 一些协议名和命令名一样（或相似）的协议
SSH Secure Shell(SSH 安全外壳协议) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络==协议==。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。
优点：
 安全！ 方便！两台机器间不用输入账号密码就可验证身份！（通过保存在服务器和客户端上的密钥）；  ssh可以传输文本与二进制文件；
主要应用：
 远程登录（可免密码）、github仓库操作 文件传输（如hdfs）  SSH的安全机制 SSH之所以能够保证安全，原因在于它采用了==非对称加密技术(RSA)==加密了所有传输的数据。
传统的网络服务程序，如FTP、POP？和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到==中间人==（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
但并不是说SSH就是绝对安全的，因为它本身提供两种级别的验证方法：
 第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人攻击”这种方式的攻击。   传统的账号密码验证？
  第二种级别（基于密钥的安全验证）：你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下（该服务器上你用的账号）寻找你（客户端）的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密“质询”(challenge)并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。与第一种级别相比，第二种级别不仅加密所有传输的数据，也不需要在网络上传送口令，因此安全性更高，可以有效防止中间人攻击。  使用  有没有命令行传文件的例子？传id的是个专门的命令  通常使用的软件工具为OpenSSH
####基于密钥的安全验证-事前准备
常用于免密登录。如果想通过输入密码的方式登录则不需要这步准备。
在本机生成一对密钥（即私钥与公钥）：
ssh-keygen -t rsa #-t表示类型选项，这里采用rsa加密算法 然后根据提示一步步的按enter键即可（其中有一个提示是要求设置私钥口令passphrase，不设置则为空，这里看心情吧，如果不放心私钥的安全可以设置一下），执行结束以后会在 /home/当前用户 目录下生成一个 .ssh 文件夹,其中包含私钥文件 id_rsa 和公钥文件 id_rsa.pub。（还有known_hosts不知道有用没） 将公钥复制到远程主机中
使用ssh-copy-id命令将公钥复制到远程主机。ssh-copy-id会将公钥写到远程主机的 ~/ .ssh/authorized_keys文件中
ssh-copy-id 用户名@ip 这样以后登录这台远程主机就不用账号密码了~
服务端准备 centos7和windows默认带有SSH工具；（OpenSSH?</description>
    </item>
    
    <item>
      <title>管理计算机上的软件</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Mon, 23 Aug 2021 16:45:08 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E7%AE%A1%E7%90%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6/</guid>
      <description>前置知识 代码+文档（bushi）
装在计算机上的软件，在硬盘上是静态的一系列代码、文件的集合，运行时成为动态的进程；
但想要保证软件正常运行，需要环境+软件+库/依赖相匹配才行
 环境：  操作系统：基本环境，也是可执行文件的直接运行环境； 运行环境：如java字节码文件需要运行在jvm里，解释型语言要运行在有解释器的操作系统上，js要在浏览器or Node.js运行一样；似乎都是非纯编译运行的语言需要；在自己的环境中运行，就不需要转换成操作系统的可执行文件； java、python等环境安装后，需要将环境的位置添加到操作系统的PATH环境变量中，以确保操作系统能找到他们。   软件  比程序要大一点的概念，也是一系列指令； 因此软件最终都会成为机器能看懂的语言，在硬盘上不论是被编译成的可执行文件，还是脚本语言文件（由解释器读入内存一行就解释一行？可能要看看py和js的原理才懂），在cpu接触前，都会成为机器语言；   库  自己的库，如C语言#include的库;Java中的jre就是jvm+基础类库 系统提供的动态链接库，如win下的dll、linux的lib文件夹内容；    软件安装方式 源码编译 下载源代码（如redis使用C语言开发、nginx基于c++开发），然后使用对应版本的编译器（如gcc）在源码文件夹下编译，最终形成可执行文件。为了方便管理，通常会用到项目管理工具如make
./configure make &amp;amp;&amp;amp; make install  make 系列命令是GNU下的自由软件，有gcc编译、打包、管理项目（C语言为主，其他语言要调用其他编译/解释器）,和maven类似属于项目管理工具（不知道会不会从网上下载依赖）
GCC是C/C++语言的编译工具，Make是增量式（编译）批处理工具，CMake是Make脚本生成工具。 在现代C/C++项目的构建中，它们的关系如下。
cmake make gcc CMakelist.txt -----&amp;gt; Makefile ----&amp;gt; Cmds ---&amp;gt; Binary  在不同cpu架构下源码包和编译器会有区别,因为底层的指令集不同；
安装流程和C语言源文件运行流程类似
安装包 msi\exe\rpm\ipk\apk\aab;
安装包也是由源码编译而成的二进制文件；但已经过官方封装，开箱即用。
单独安装安装包可能会遇到安装包之间的依赖问题。
包管理器 应用商店等也是类似的角色,在官方的服务器上统一管理安装包;
apt、yum、rpm、pip、winget等，从源（保管安装包的服务器）上下载安装软件或安装包；可以通过写配置文件等操作来指定多个源；
一些包管理器可以帮助解决依赖等问题。
 除了软件下载外，类似的操作还有maven、nodejs、docker等，对库、包进行管理（包括下载），同时有些具有项目管理功能
 npm npm 是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。</description>
    </item>
    
    <item>
      <title>文件系统</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 05 Aug 2021 17:07:35 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。
文件系统由三部分组成：文件系统的接口，对对象操作和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。
 UFS：联合文件系统 Docker使用的系统
UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。
HDFS Hadoop生态系统中的分布式文件系统</description>
    </item>
    
    <item>
      <title>Hugo博客搭建经验</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Mon, 26 Jul 2021 16:47:18 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/hugo%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</guid>
      <description>写在前面 ​	hugo最强使用技巧：别用hugo (狗头)
​	这个世界上的静态网站生成器至少有333个，先从我的角度说说其他静态网站生成器的优点：
  VuePress：基于vue构建，可以顺便练习vue，减小web开发者的学习成本;
  中文文档
  主题丰富（在github主页有）
  插件挺丰富，不知道常用的有没，但是大丈夫！因为是Vue，自己集成功能很方便！
  文档说是单页应用，解决路由时音乐播放器重新加载播放的问题应该简单一些；
    Hexo：由中国台湾人创建，咱们用的人多所以网上教程丰富；
 [√]中文文档 [√]主题丰富 [√]插件齐全（几乎不用敲代码，npm上都一堆插件） 多个静态页面    WordPress:嗯。。和hugo都是老外搞的，风格半斤八两，都用了&amp;quot;shortcode&amp;quot;这种奇怪的东西（类似模板引擎或vue的组件，但还需要额外的学习成本），支持OneNote上传笔记（鸡肋）；可以和PHP配套使用；
然后。。。hugo的优点可能是快？我不知道。。。可我是男人可如果开发速度慢、学习成本高不还相当于慢了。。中文文档还相当于没有！
如果重命名content下的md文件，hugo编译时不会把删掉该替换的文件。不知道其他工具怎么样。
当然所有工具都是没有上限的！只是==碰壁次数与资料多少、学习成本==之类的区别！
  快速开始 中文文档少有的中文233：
快速入门 | Hugo 中文网 (gohugo.cn)
其中下载主题这步可以自己选，主题商城也在这个网站中↑；
我所用的主题是Diary，可以在博客左下↙版权那里找到github仓库。自己魔改了一部分，为了添加功能。
常用命令、脚本 ​	获取QQ头像的url:	https://q1.qlogo.cn/g?b=qq&amp;amp;nk=QQ号码&amp;amp;s=640。用edge浏览器的时候发现，如果用https访问博客，头像url用http访问的话会被拦截。
​	每次输入这么多命令太麻烦了，hugo似乎没有把自己提交到github的命令，索性写了一个windows脚本上传博客。提前在path环境变量中配置hugo命令所在目录，以在任意位置执行hugo命令。
​	还是第一次主动写windows脚本，上一次写还是上一次（呸，上次是改U盘图标，照网上抄的）。脚本文件后缀名为.bat，直接在里面写命令即可。
hugo -D hugo cd ./public git add -A git commit -m &amp;#34;脚本提交&amp;#34; git push -u origin master ​	先执行一遍hugo -D是为了将草稿也编译一下；再不带-D，这样主页不会显示草稿；</description>
    </item>
    
    <item>
      <title>tips</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/tips/</link>
      <pubDate>Sat, 24 Jul 2021 18:06:08 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/tips/</guid>
      <description>数学嘛，又不是主业，实用的该用时想起来就好，其他的看兴趣啦~高中我不都是按兴趣学的嘛~
考研数学 出题套路 加过来减过去；四则运算；没思路时先试试
2020把加减又变成大于小于；
张宇高数第一讲 等式 =&amp;gt; 两边取极限、倒数、积分、同乘同除同加减、取对数，换位置，目的是得到想要的。
出题套路 =&amp;gt; 改变数字顺序，把本来该在一起的拆开(例1.1)；有些将来会被消掉，不用怕。
换元：无法拆开的xt、x-t等换元。比如f(xt)
数形结合百般好；别光给哪儿捯饬等式，画图啊！看看性状面积啥的
第二讲 已知不等式：
 sinx &amp;lt;= x；sinx其实比x小，看泰勒展开式就知道；同济书里的证明：  例2.13：
第四讲之前 奇奇得偶；奇函数泰勒展开不会有偶数次方；
辞典 懒加载 web:load on demand 需要时才于后端交互（如百度图片下拉显示更多）。缓存虽然能一定程度上解决访问后端较慢的问题，但缓存不能存大量数据。
java：Lazy load </description>
    </item>
    
    <item>
      <title>灵鸡一动</title>
      <link>https://baiban114.github.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/</link>
      <pubDate>Wed, 21 Jul 2021 05:37:27 +0800</pubDate>
      
      <guid>https://baiban114.github.io/tablerow.github.io/posts/%E7%81%B5%E9%B8%A1%E4%B8%80%E5%8A%A8/</guid>
      <description>使用次数少的（比如安装软件，也没遇到意外情况）就不需要记录了。相同主题整理的多了要考虑拆分，像分库分表一样。
知识类分三档：死记硬背的、理解的、容易忘也不好整理进体系的小tips。本页记录理解档内容
 知识内容都是自己的理解，要时长更新纠错
标题灵感来自高中物理老师ᕕ( ᐛ )ᕗ
老生常谈的概念 动态和静态    动态 静态 出处|例子     运行时、在内存中==结构==可变的 编译后确定，运行时不可变的 动/静语言   随数据而变的 写死的文件 动态页面，动/静态服务器   被调度、分配资源、随运行时环境而改变；上下文/命名空间等限制 程序、作业、镜像 操作系统、Docker    应该雀食哈，动态才有状态转换的概念
 常见概念：线性、连续、离散、顺序、索引、链式
 物理存储上的概念： 这四项在逻辑结构中也有对应的表：顺序表（数组）、链表、索引表、哈希表。
  顺序
 一个接一个的，连续的，有序的（唯一前驱和后缀关系）    链式
  索引
  哈希
  顺序 顺序存储指的是，集合里面的元素都是按照次序排列在一块连续的存储空间中；
在文件中的话
顺序文件
 优势:读、写一大批记录 缺点： 查找、修改、增加、删除单条记录  索引 建立索引表，从索引表直接读取地址</description>
    </item>
    
  </channel>
</rss>
